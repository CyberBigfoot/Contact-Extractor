import os
import re
import threading
import webbrowser
import time
import json
import configparser
import traceback
from tkinter import ttk, messagebox, filedialog, simpledialog
import tkinter as tk
from tkinter.scrolledtext import ScrolledText
import pandas as pd
import msal
import requests
from datetime import datetime, timedelta
import base64
import io
from openpyxl import load_workbook
import glob

# --- Configuration File Handling ---
CONFIG_FILE = 'config.ini'


def load_config():
    """Loads configuration from the ini file."""
    config = configparser.ConfigParser()
    if not os.path.exists(CONFIG_FILE):
        # Create a default config file if it doesn't exist
        config['Azure'] = {'client_id': '', 'tenant_id': ''}
        config['Appearance'] = {'theme': 'dark'}
        with open(CONFIG_FILE, 'w') as configfile:
            config.write(configfile)
        return {'client_id': '', 'tenant_id': '', 'theme': 'dark'}

    config.read(CONFIG_FILE)
    return {
        'client_id': config.get('Azure', 'client_id', fallback=''),
        'tenant_id': config.get('Azure', 'tenant_id', fallback=''),
        'theme': config.get('Appearance', 'theme', fallback='dark')
    }


def save_config(client_id, tenant_id, theme='dark'):
    """Saves configuration to the ini file."""
    config = configparser.ConfigParser()
    config['Azure'] = {'client_id': client_id, 'tenant_id': tenant_id}
    config['Appearance'] = {'theme': theme}
    with open(CONFIG_FILE, 'w') as configfile:
        config.write(configfile)


# --- Theme Configuration ---
THEMES = {
    'dark': {
        'bg': '#1e1e1e',
        'fg': '#e0e0e0',
        'accent': '#0d7377',
        'accent_hover': '#14b1b8',
        'secondary': '#2d2d2d',
        'border': '#3d3d3d',
        'button_bg': '#0d7377',
        'button_fg': '#ffffff',
        'button_active': '#14b1b8',
        'entry_bg': '#2d2d2d',
        'entry_fg': '#e0e0e0',
        'frame_bg': '#252525',
        'label_fg': '#b0b0b0',
        'highlight': '#323edd',
        'success': '#4caf50',
        'warning': '#ff9800',
        'error': '#f44336',
        'scrollbar': '#3d3d3d',
        'scrollbar_active': '#505050'
    },
    'light': {
        'bg': '#f5f5f5',
        'fg': '#212121',
        'accent': '#0d7377',
        'accent_hover': '#14b1b8',
        'secondary': '#ffffff',
        'border': '#e0e0e0',
        'button_bg': '#0d7377',
        'button_fg': '#ffffff',
        'button_active': '#14b1b8',
        'entry_bg': '#ffffff',
        'entry_fg': '#212121',
        'frame_bg': '#fafafa',
        'label_fg': '#616161',
        'highlight': '#5c6bc0',
        'success': '#66bb6a',
        'warning': '#ffa726',
        'error': '#ef5350',
        'scrollbar': '#bdbdbd',
        'scrollbar_active': '#9e9e9e'
    }
}

# --- Load initial configuration ---
config_values = load_config()
CLIENT_ID = config_values['client_id']
TENANT_ID = config_values['tenant_id']
AUTHORITY = f"https://login.microsoftonline.com/{TENANT_ID}"
SCOPES = ["https://graph.microsoft.com/.default"]

# Try to import PST processing libraries
try:
    import pypff

    PST_SUPPORT = True
except ImportError:
    PST_SUPPORT = False
    print("PST/OST support not available. Install libpff-win32 (Windows) or libpff (Linux/Mac)")

# Try to import Windows COM support
try:
    import win32com.client

    COM_SUPPORT = True
except ImportError:
    COM_SUPPORT = False
    print("Windows COM support not available. Install pypiwin32")


class OnlineDataExtractor:
    """Handles extraction of contact data from Microsoft Graph API"""

    def __init__(self, access_token):
        self.access_token = access_token
        self.headers = {'Authorization': f'Bearer {access_token}',
                        'Content-Type': 'application/json'}
        self.base_url = "https://graph.microsoft.com/v1.0"
        self.contacts_data = []
        self.progress_callback = None
        self.status_callback = None
        self.debug_callback = None
        self.start_date = None
        self.end_date = None
        self.outbound_only = False  # Flag for outbound-only filtering
        self.current_user_email = None  # Store current user's email

    def set_outbound_only(self, outbound_only):
        """Set whether to filter for outbound emails only"""
        self.outbound_only = outbound_only
        if outbound_only:
            self.update_debug("Outbound-only mode enabled: will only process sent emails and their recipients")

    def set_callbacks(self, progress_callback, status_callback, debug_callback=None):
        """Set callbacks for progress, status, and debug updates"""
        self.progress_callback = progress_callback
        self.status_callback = status_callback
        self.debug_callback = debug_callback

    def update_status(self, message):
        """Update status message via callback"""
        if self.status_callback:
            self.status_callback(message)

    def update_progress(self, value):
        """Update progress bar via callback"""
        if self.progress_callback:
            self.progress_callback(value)

    def update_debug(self, message):
        """Update debug information via callback"""
        if self.debug_callback:
            self.debug_callback(message)

    def set_date_range(self, start_date, end_date):
        """Set the date range for scanning"""
        self.start_date = start_date
        self.end_date = end_date

    def extract_emails(self):
        """Extract names and emails from user's emails"""
        self.update_status("Scanning emails...")
        self.update_debug("Starting email extraction...")

        try:
            # Format dates for API - use proper ISO 8601 format
            start_date_str = self.start_date.strftime("%Y-%m-%dT%H:%M:%SZ")
            end_date_str = self.end_date.strftime("%Y-%m-%dT%H:%M:%SZ")

            self.update_debug(f"Scanning emails from {start_date_str} to {end_date_str}")

            if self.outbound_only:
                self.update_debug("Outbound-only mode: Scanning Sent Items folder")
                url = f"{self.base_url}/me/mailFolders/SentItems/messages?$filter=sentDateTime ge {start_date_str} and sentDateTime le {end_date_str}&$select=subject,from,toRecipients,ccRecipients,bccRecipients,body&$top=100"
            else:
                self.update_debug("Standard mode: Scanning Inbox folder")
                url = f"{self.base_url}/me/messages?$filter=receivedDateTime ge {start_date_str} and receivedDateTime le {end_date_str}&$select=subject,from,toRecipients,ccRecipients,bccRecipients,body&$top=100"

            processed_emails = 0

            while url:
                self.update_debug(f"Fetching emails from: {url}")
                response = requests.get(url, headers=self.headers)

                if response.status_code != 200:
                    self.update_debug(f"Error fetching emails: {response.status_code} - {response.text}")
                    self.update_status(f"Error fetching emails: {response.status_code}")
                    break

                data = response.json()
                emails = data.get('value', [])

                self.update_debug(f"Processing {len(emails)} emails...")

                for email in emails:
                    if self.outbound_only:
                        # Process recipients only
                        for recipient_type in ['toRecipients', 'ccRecipients', 'bccRecipients']:
                            if recipient_type in email:
                                for recipient in email[recipient_type]:
                                    self._process_email_person(recipient['emailAddress'], "Email (Outbound)")
                                    self.update_debug(
                                        f"Processed recipient: {recipient['emailAddress'].get('emailAddress', 'N/A')}")
                    else:
                        # Original behavior - process sender and recipients
                        # Process sender
                        if 'from' in email and email['from']:
                            self._process_email_person(email['from']['emailAddress'], "Email")
                            self.update_debug(
                                f"Processed sender: {email['from']['emailAddress'].get('emailAddress', 'N/A')}")

                        # Process recipients
                        for recipient_type in ['toRecipients', 'ccRecipients', 'bccRecipients']:
                            if recipient_type in email:
                                for recipient in email[recipient_type]:
                                    self._process_email_person(recipient['emailAddress'], "Email")
                                    self.update_debug(
                                        f"Processed recipient: {recipient['emailAddress'].get('emailAddress', 'N/A')}")

                    # Process body for name/email patterns
                    if 'body' in email and email['body']:
                        body_text = email['body'].get('content', '')
                        if body_text:
                            # General text extraction
                            self._extract_from_text(body_text, "Email Body")
                            # Specific signature extraction
                            self._extract_from_email_signature(body_text, "Email Signature")

                    # Process attachments
                    if 'hasAttachments' in email and email['hasAttachments']:
                        self._process_email_attachments(email['id'])

                    processed_emails += 1

                # Update progress
                progress = 15 * (processed_emails / 1000) if processed_emails > 0 else 15  # Rough estimate
                self.update_progress(min(progress, 15))

                # Check for next page
                if '@odata.nextLink' in data:
                    url = data['@odata.nextLink']
                else:
                    url = None

            self.update_debug(f"Email extraction complete. Processed {processed_emails} emails.")

        except Exception as e:
            self.update_debug(f"Error extracting emails: {str(e)}\n{traceback.format_exc()}")
            self.update_status(f"Error extracting emails: {str(e)}")

    def extract_all_mailboxes(self):
        """Extract names and emails from all mailboxes in the organization"""
        self.update_status("Scanning all mailboxes in the organization...")
        self.update_debug("Starting extraction from all mailboxes...")

        try:
            # Format dates for API - use proper ISO 8601 format
            start_date_str = self.start_date.strftime("%Y-%m-%dT%H:%M:%SZ")
            end_date_str = self.end_date.strftime("%Y-%m-%dT%H:%M:%SZ")

            self.update_debug(f"Scanning all mailboxes from {start_date_str} to {end_date_str}")

            # Get all users in the organization
            users_url = f"{self.base_url}/users?$select=id,mail,userPrincipalName&$top=999"
            users_response = requests.get(users_url, headers=self.headers)

            if users_response.status_code != 200:
                self.update_debug(f"Error fetching users: {users_response.status_code} - {users_response.text}")
                self.update_status(f"Error fetching users: {users_response.status_code}")
                return False

            users_data = users_response.json()
            users = users_data.get('value', [])

            self.update_debug(f"Found {len(users)} users in the organization")

            total_users = len(users)
            processed_users = 0

            for user in users:
                user_id = user.get('id')
                user_email = user.get('mail') or user.get('userPrincipalName', '')

                if not user_id or not user_email:
                    continue

                self.update_status(f"Scanning mailbox: {user_email} ({processed_users + 1}/{total_users})")

                if self.outbound_only:
                    url = f"{self.base_url}/users/{user_id}/mailFolders/SentItems/messages?$filter=sentDateTime ge {start_date_str} and sentDateTime le {end_date_str}&$select=subject,from,toRecipients,ccRecipients,bccRecipients,body&$top=100"
                else:
                    url = f"{self.base_url}/users/{user_id}/messages?$filter=receivedDateTime ge {start_date_str} and receivedDateTime le {end_date_str}&$select=subject,from,toRecipients,ccRecipients,bccRecipients,body&$top=100"

                processed_emails = 0

                while url:
                    self.update_debug(f"Fetching emails from: {url}")
                    response = requests.get(url, headers=self.headers)

                    if response.status_code != 200:
                        self.update_debug(
                            f"Error fetching emails for {user_email}: {response.status_code} - {response.text}")
                        break

                    data = response.json()
                    emails = data.get('value', [])

                    self.update_debug(f"Processing {len(emails)} emails from {user_email}...")

                    for email in emails:
                        if self.outbound_only:
                            # Process recipients only
                            for recipient_type in ['toRecipients', 'ccRecipients', 'bccRecipients']:
                                if recipient_type in email:
                                    for recipient in email[recipient_type]:
                                        self._process_email_person(recipient['emailAddress'],
                                                                   f"Company Mailbox (Outbound): {user_email}")
                                        self.update_debug(
                                            f"Processed recipient: {recipient['emailAddress'].get('emailAddress', 'N/A')}")
                        else:
                            # Original behavior - process sender and recipients
                            # Process sender
                            if 'from' in email and email['from']:
                                self._process_email_person(email['from']['emailAddress'],
                                                           f"Company Mailbox: {user_email}")
                                self.update_debug(
                                    f"Processed sender: {email['from']['emailAddress'].get('emailAddress', 'N/A')}")

                            # Process recipients
                            for recipient_type in ['toRecipients', 'ccRecipients', 'bccRecipients']:
                                if recipient_type in email:
                                    for recipient in email[recipient_type]:
                                        self._process_email_person(recipient['emailAddress'],
                                                                   f"Company Mailbox: {user_email}")
                                        self.update_debug(
                                            f"Processed recipient: {recipient['emailAddress'].get('emailAddress', 'N/A')}")

                        # Process body for name/email patterns
                        if 'body' in email and email['body']:
                            body_text = email['body'].get('content', '')
                            if body_text:
                                # General text extraction
                                self._extract_from_text(body_text, f"Company Mailbox Body: {user_email}")
                                # Specific signature extraction
                                self._extract_from_email_signature(body_text,
                                                                   f"Company Mailbox Signature: {user_email}")

                        # Process attachments
                        if 'hasAttachments' in email and email['hasAttachments']:
                            self._process_email_attachments(email['id'], f"Company Mailbox: {user_email}")

                        processed_emails += 1

                    # Check for next page
                    if '@odata.nextLink' in data:
                        url = data['@odata.nextLink']
                    else:
                        url = None

                processed_users += 1

                # Update progress
                progress = 15 + 25 * (processed_users / total_users) if total_users > 0 else 15
                self.update_progress(min(progress, 40))

            self.update_debug(f"All mailboxes extraction complete. Processed {processed_users} users.")
            return True

        except Exception as e:
            self.update_debug(f"Error extracting from all mailboxes: {str(e)}\n{traceback.format_exc()}")
            self.update_status(f"Error extracting from all mailboxes: {str(e)}")
            return False

    def extract_shared_mailbox_emails(self, mailbox_email):
        """Extract names and emails from a shared mailbox"""
        self.update_status(f"Scanning shared mailbox: {mailbox_email}...")
        self.update_debug(f"Starting shared mailbox extraction for: {mailbox_email}")

        try:
            # Format dates for API - use proper ISO 8601 format
            start_date_str = self.start_date.strftime("%Y-%m-%dT%H:%M:%SZ")
            end_date_str = self.end_date.strftime("%Y-%m-%dT%H:%M:%SZ")

            self.update_debug(f"Scanning shared mailbox emails from {start_date_str} to {end_date_str}")

            # Get user ID from email
            user_url = f"{self.base_url}/users/{mailbox_email}"
            user_response = requests.get(user_url, headers=self.headers)

            if user_response.status_code != 200:
                self.update_debug(f"Error finding user: {user_response.status_code} - {user_response.text}")
                self.update_status(f"Error finding user: {mailbox_email}")
                return False

            user_data = user_response.json()
            user_id = user_data.get('id')

            if not user_id:
                self.update_debug(f"Could not find user ID for: {mailbox_email}")
                self.update_status(f"Error finding user ID for: {mailbox_email}")
                return False

            if self.outbound_only:
                url = f"{self.base_url}/users/{user_id}/mailFolders/SentItems/messages?$filter=sentDateTime ge {start_date_str} and sentDateTime le {end_date_str}&$select=subject,from,toRecipients,ccRecipients,bccRecipients,body&$top=100"
            else:
                url = f"{self.base_url}/users/{user_id}/messages?$filter=receivedDateTime ge {start_date_str} and receivedDateTime le {end_date_str}&$select=subject,from,toRecipients,ccRecipients,bccRecipients,body&$top=100"

            processed_emails = 0

            while url:
                self.update_debug(f"Fetching shared mailbox emails from: {url}")
                response = requests.get(url, headers=self.headers)

                if response.status_code != 200:
                    self.update_debug(f"Error fetching shared mailbox emails: {response.status_code} - {response.text}")
                    self.update_status(f"Error fetching shared mailbox emails: {response.status_code}")
                    return False

                data = response.json()
                emails = data.get('value', [])

                self.update_debug(f"Processing {len(emails)} shared mailbox emails...")

                for email in emails:
                    if self.outbound_only:
                        # Process recipients only
                        for recipient_type in ['toRecipients', 'ccRecipients', 'bccRecipients']:
                            if recipient_type in email:
                                for recipient in email[recipient_type]:
                                    self._process_email_person(recipient['emailAddress'],
                                                               f"Shared Mailbox (Outbound): {mailbox_email}")
                                    self.update_debug(
                                        f"Processed recipient: {recipient['emailAddress'].get('emailAddress', 'N/A')}")
                    else:
                        # Original behavior - process sender and recipients
                        # Process sender
                        if 'from' in email and email['from']:
                            self._process_email_person(email['from']['emailAddress'],
                                                       f"Shared Mailbox: {mailbox_email}")
                            self.update_debug(
                                f"Processed sender: {email['from']['emailAddress'].get('emailAddress', 'N/A')}")

                        # Process recipients
                        for recipient_type in ['toRecipients', 'ccRecipients', 'bccRecipients']:
                            if recipient_type in email:
                                for recipient in email[recipient_type]:
                                    self._process_email_person(recipient['emailAddress'],
                                                               f"Shared Mailbox: {mailbox_email}")
                                    self.update_debug(
                                        f"Processed recipient: {recipient['emailAddress'].get('emailAddress', 'N/A')}")

                    # Process body for name/email patterns
                    if 'body' in email and email['body']:
                        body_text = email['body'].get('content', '')
                        if body_text:
                            # General text extraction
                            self._extract_from_text(body_text, f"Shared Mailbox Body: {mailbox_email}")
                            # Specific signature extraction
                            self._extract_from_email_signature(body_text, f"Shared Mailbox Signature: {mailbox_email}")

                    # Process attachments
                    if 'hasAttachments' in email and email['hasAttachments']:
                        self._process_email_attachments(email['id'], f"Shared Mailbox: {mailbox_email}")

                    processed_emails += 1

                # Update progress
                progress = 15 + 10 * (processed_emails / 1000) if processed_emails > 0 else 15  # Rough estimate
                self.update_progress(min(progress, 25))

                # Check for next page
                if '@odata.nextLink' in data:
                    url = data['@odata.nextLink']
                else:
                    url = None

            self.update_debug(f"Shared mailbox extraction complete. Processed {processed_emails} emails.")
            return True

        except Exception as e:
            self.update_debug(f"Error extracting shared mailbox emails: {str(e)}\n{traceback.format_exc()}")
            self.update_status(f"Error extracting shared mailbox emails: {str(e)}")
            return False

    # NEW: Improved signature extraction methods
    def _extract_from_email_signature(self, text, source):
        """Extracts names, emails, phone numbers, and company names from an email signature block."""
        if not text:
            return

        # Common patterns that precede a signature
        signature_delimiters = [
            r'(?:^|\n)--+\s*(?:\n|$)',
            r'(?:^|\n)---+\s*(?:\n|$)',
            r'(?:^|\n)(?:Thanks|Regards|Best regards|Sincerely|Cheers|Kind regards|Warm regards|Best|Cordially),?\s*(?:\n|$)',
        ]

        # Try to find ALL potential signature blocks
        signature_blocks = []

        for delimiter_pattern in signature_delimiters:
            matches = list(re.finditer(delimiter_pattern, text, re.IGNORECASE | re.MULTILINE))
            for match in matches:
                # Get text after delimiter (next 500 chars should be enough for a signature)
                start_pos = match.end()
                end_pos = min(start_pos + 500, len(text))
                signature_block = text[start_pos:end_pos].strip()

                if signature_block and len(signature_block) > 10:  # Ignore very short blocks
                    signature_blocks.append(signature_block)

        # If no signature blocks found, try to extract from the last 300 characters
        if not signature_blocks and len(text) > 300:
            signature_blocks.append(text[-300:])

        # Process each signature block
        for signature_block in signature_blocks:
            self._process_signature_block(signature_block, source)

    def _process_signature_block(self, signature_block, source):
        """Process a single signature block to extract contact information."""
        # Extract all emails from this block
        email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        emails = re.findall(email_pattern, signature_block)

        if not emails:
            return

        # Extract all phone numbers from this block
        phones = self._extract_all_phone_numbers(signature_block)

        # Extract all potential names from this block
        names = self._extract_all_names(signature_block)

        # Extract all potential company names from this block
        companies = self._extract_all_company_names(signature_block)

        # For each email found, try to associate it with nearby name, phone, and company
        for email in emails:
            email = email.lower()

            # Find the best matching name (closest to the email in the text)
            best_name = self._find_closest_match(signature_block, email, names)

            # Find the best matching phone (closest to the email in the text)
            best_phone = self._find_closest_match(signature_block, email, phones) if phones else ""

            # Find the best matching company (closest to the email in the text)
            best_company = self._find_closest_match(signature_block, email, companies) if companies else ""

            # If no company found, try to extract from email domain
            if not best_company:
                best_company = self._extract_company_from_email(email)

            # Extract first and last name
            if best_name:
                first_name, last_name = self._extract_name_parts(best_name)
            else:
                # Fall back to email-based name
                name = email.split('@')[0].replace('.', ' ').replace('_', ' ').title()
                first_name, last_name = self._extract_name_parts(name)

            # Add contact
            self._add_contact(first_name, last_name, email, source, best_phone, best_company)
            self.update_debug(
                f"Extracted from signature: {first_name} {last_name} - {email} - Phone: {best_phone} - Company: {best_company}"
            )

    def _extract_all_phone_numbers(self, text):
        """Extract all phone numbers from text using improved regex patterns."""
        phone_patterns = [
            r'\+?1?\s*\(?([0-9]{3})\)?[\s.-]?([0-9]{3})[\s.-]?([0-9]{4})',  # US/Canada
            r'\+([0-9]{1,3})\s*\(?([0-9]{1,4})\)?[\s.-]?([0-9]{3,4})[\s.-]?([0-9]{4})',  # International
        ]

        phones = []
        seen_normalized = set()  # Track normalized versions to avoid duplicates

        for pattern in phone_patterns:
            matches = re.finditer(pattern, text)
            for match in matches:
                phone = match.group(0).strip()

                # Normalize the phone number for duplicate detection
                # Remove all spaces, dashes, parentheses, and plus signs
                normalized = re.sub(r'[\s\-\(\)\+\.]', '', phone)

                # Skip if we've already found this number
                if normalized in seen_normalized:
                    continue

                # Skip if it's too short or too long
                if len(normalized) < 10 or len(normalized) > 15:
                    continue

                seen_normalized.add(normalized)

                # Format the phone number nicely
                phone = re.sub(r'\s+', ' ', phone)  # Normalize spaces
                phones.append(phone)

        return phones

    def _extract_all_names(self, text):
        """Extract all potential names from text."""
        # Look for capitalized words that could be names
        # This pattern looks for 2-4 consecutive capitalized words
        name_patterns = [
            r'\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,3})\b',  # John Smith, John Q. Smith, etc.
            r'\b([A-Z]\.\s*[A-Z][a-z]+)\b',  # J. Smith
            r'\b([A-Z][a-z]+\s+[A-Z]\.)\b',  # John S.
        ]

        names = []
        for pattern in name_patterns:
            matches = re.finditer(pattern, text)
            for match in matches:
                name = match.group(1).strip()
                # Filter out common words that aren't names
                if name and not any(word in name.lower() for word in
                                    ['the', 'and', 'for', 'with', 'from', 'office', 'mobile', 'phone', 'email',
                                     'direct']):
                    if name not in names:
                        names.append(name)

        return names

    def _extract_all_company_names(self, text):
        """Extract all potential company names from text with improved patterns."""
        company_patterns = [
            # Companies with legal suffixes (most reliable)
            r'\b([A-Z][A-Za-z0-9\s&]{1,50}?(?:Inc\.?|LLC|LLP|Ltd\.?|Co\.?|Corp\.?|Corporation|Company|GmbH|S\.A\.|SA|Pty\.?\s*Ltd\.?|Limited))\b',
            # Standalone business words (Group, International, etc.)
            r'\b([A-Z][A-Za-z0-9\s&]{2,40}?(?:Group|International|Solutions|Technologies|Systems|Partners|Associates|Enterprises|Consulting|Services))\b',
            # All-caps company names (common in signatures) - 2 to 6 words
            r'\b([A-Z]{2,}(?:\s+[A-Z]{2,}){0,5})\b',
            # Title case near signature indicators (like | or line breaks before contact info)
            r'(?:^|\n)([A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,4})(?:\s*\n|\s*\|)',
        ]

        companies = []

        # Common words that indicate we've grabbed too much context
        context_words = [
            'if you need', 'in regard', 'related to', 'work for', 'working at',
            'employed by', 'anything urgent', 'please contact', 'feel free',
            'reach out', 'get in touch', 'let me know', 'thank you', 'thanks',
            'best regards', 'sincerely', 'kind regards', 'warm regards'
        ]

        for pattern in company_patterns:
            matches = re.finditer(pattern, text, re.MULTILINE)
            for match in matches:
                company = match.group(1).strip()

                # Clean up the company name
                company = re.sub(r'\s+', ' ', company)

                # Skip if it contains context words (these mean we grabbed surrounding text)
                if any(context_word in company.lower() for context_word in context_words):
                    # Try to extract just the company name from the context
                    # Look for the last capitalized sequence before the legal suffix
                    for sub_pattern in [r'([A-Z][A-Za-z\s&]{2,30}?(?:Inc\.?|LLC|LLP|Ltd\.?|Co\.?|Corp\.?)',
                                        r'([A-Z][A-Za-z\s&]{2,30}?(?:Group|International|Solutions|Technologies))']:
                        sub_match = re.search(sub_pattern, company)
                        if sub_match:
                            company = sub_match.group(1).strip()
                            break
                    else:
                        continue  # Skip this match if we can't extract clean company name

                # Filter out common false positives
                false_positives = ['phone', 'mobile', 'email', 'direct', 'office', 'cell',
                                   'street', 'avenue', 'road', 'drive', 'suite', 'floor',
                                   'dear', 'hello', 'hi there']

                if company and not any(word in company.lower() for word in false_positives):
                    # Must be between 3 and 60 characters
                    if 3 <= len(company) <= 60 and company not in companies:
                        companies.append(company)

        return companies

    def _find_closest_match(self, text, anchor, candidates):
        """Find the candidate closest to the anchor text in the string."""
        if not candidates:
            return ""

        anchor_pos = text.lower().find(anchor.lower())
        if anchor_pos == -1:
            return candidates[0] if candidates else ""

        closest = None
        min_distance = float('inf')

        for candidate in candidates:
            candidate_pos = text.find(candidate)
            if candidate_pos != -1:
                distance = abs(candidate_pos - anchor_pos)
                if distance < min_distance:
                    min_distance = distance
                    closest = candidate

        return closest if closest else (candidates[0] if candidates else "")

    def _extract_phone_number(self, text):
        """Extract the first phone number from text (kept for backward compatibility)."""
        phones = self._extract_all_phone_numbers(text)
        return phones[0] if phones else ""

    def _extract_company_name(self, text):
        """Extract the first company name from text (kept for backward compatibility)."""
        companies = self._extract_all_company_names(text)
        return companies[0] if companies else ""

    def _extract_company_from_email(self, email):
        """Extract company name from email domain with improved logic."""
        if not email or '@' not in email:
            return ""

        # Extract domain from email
        domain = email.split('@')[1].lower()

        # Skip common free email providers
        free_providers = [
            'gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com', 'aol.com',
            'icloud.com', 'live.com', 'msn.com', 'me.com', 'ymail.com',
            'protonmail.com', 'mail.com', 'zoho.com', 'gmx.com'
        ]

        if domain in free_providers:
            return ""

        # Remove common subdomains
        domain_parts = domain.split('.')
        if len(domain_parts) < 2:
            return ""

        # Remove common prefixes
        if domain_parts[0] in ['mail', 'www', 'email', 'smtp', 'exchange', 'webmail', 'portal']:
            domain_parts = domain_parts[1:]

        # Get the main domain (second-level domain)
        if len(domain_parts) >= 2:
            company = domain_parts[0]

            # Clean up the company name
            # Replace hyphens and underscores with spaces
            company = re.sub(r'[-_]', ' ', company)
            # Capitalize properly
            company = company.title()

            return company

        return ""

    def _process_email_person(self, email_address, source):
        """Process an email address object and extract name/email"""
        if not email_address:
            return

        email = email_address.get('emailAddress', '').lower()
        name = email_address.get('name', '')

        if email:
            # If name is empty, try to extract from email
            if not name:
                name = email.split('@')[0].replace('.', ' ').title()

            # Extract first and last name
            first_name, last_name = self._extract_name_parts(name)

            # Extract company from email domain
            company = self._extract_company_from_email(email)

            # Add to contacts if not already present
            self._add_contact(first_name, last_name, email, source, "", company)

    def _process_email_attachments(self, email_id, source="Email"):
        """Process attachments in an email with optional source parameter"""
        try:
            url = f"{self.base_url}/me/messages/{email_id}/attachments"
            response = requests.get(url, headers=self.headers)

            if response.status_code == 200:
                attachments = response.json().get('value', [])

                for attachment in attachments:
                    if attachment.get('isInline', False):
                        continue  # Skip inline images and similar

                    # Process Excel attachments
                    if attachment.get(
                            'contentType') == 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet':
                        self._process_excel_attachment(attachment, source)

                    # Process other document types that might contain contact info
                    elif attachment.get('contentType') in ['application/pdf',
                                                           'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                                                           'text/plain']:
                        # For simplicity, we'll just extract from the attachment name
                        name = attachment.get('name', '')
                        self._extract_from_text(name, f"{source} Attachment Name")

        except Exception as e:
            self.update_debug(f"Error processing attachments: {str(e)}")

    def _process_excel_attachment(self, attachment, source="Email"):
        """Process an Excel attachment to extract contact information with optional source parameter"""
        try:
            # Get attachment content
            content_bytes = base64.b64decode(attachment.get('contentBytes', ''))

            # Load Excel file
            wb = load_workbook(io.BytesIO(content_bytes), read_only=True)

            for sheet_name in wb.sheetnames:
                sheet = wb[sheet_name]

                for row in sheet.iter_rows(values_only=True):
                    row_text = ' '.join([str(cell) for cell in row if cell is not None])
                    self._extract_from_text(row_text, f"{source} Excel Attachment: {attachment.get('name', 'Unknown')}")

            wb.close()

        except Exception as e:
            self.update_debug(f"Error processing Excel attachment: {str(e)}")

    def extract_calendar_events(self):
        """Extract names and emails from calendar events"""
        self.update_status("Scanning calendar events...")
        self.update_debug("Starting calendar event extraction...")

        try:
            # Format dates for API - use proper ISO 8601 format
            start_date_str = self.start_date.strftime("%Y-%m-%dT%H:%M:%SZ")
            end_date_str = self.end_date.strftime("%Y-%m-%dT%H:%M:%SZ")

            self.update_debug(f"Scanning calendar events from {start_date_str} to {end_date_str}")

            url = f"{self.base_url}/me/calendar/calendarView?startDateTime={start_date_str}&endDateTime={end_date_str}&$select=subject,attendees&$top=100"

            processed_events = 0

            while url:
                response = requests.get(url, headers=self.headers)
                if response.status_code != 200:
                    self.update_debug(f"Error fetching calendar events: {response.status_code} - {response.text}")
                    self.update_status(f"Error fetching calendar events: {response.status_code}")
                    break

                data = response.json()
                events = data.get('value', [])

                self.update_debug(f"Processing {len(events)} events...")

                for event in events:
                    # Process attendees
                    if 'attendees' in event:
                        for attendee in event['attendees']:
                            if 'emailAddress' in attendee:
                                self._process_email_person(attendee['emailAddress'], "Calendar Event")
                                self.update_debug(
                                    f"Processed attendee: {attendee['emailAddress'].get('emailAddress', 'N/A')}")

                    processed_events += 1

                # Update progress
                progress = 40 + 15 * (processed_events / 1000) if processed_events > 0 else 40
                self.update_progress(min(progress, 55))

                # Check for next page
                if '@odata.nextLink' in data:
                    url = data['@odata.nextLink']
                else:
                    url = None

            self.update_debug(f"Calendar event extraction complete. Processed {processed_events} events.")

        except Exception as e:
            self.update_debug(f"Error extracting calendar events: {str(e)}\n{traceback.format_exc()}")
            self.update_status(f"Error extracting calendar events: {str(e)}")

    def extract_contacts(self):
        """Extract names and emails from contacts"""
        self.update_status("Scanning contacts...")
        self.update_debug("Starting contacts extraction...")

        try:
            url = f"{self.base_url}/me/contacts?$select=displayName,emailAddresses,companyName,homePhone,mobilePhone,businessPhones&$top=100"

            processed_contacts = 0

            while url:
                response = requests.get(url, headers=self.headers)
                if response.status_code != 200:
                    self.update_debug(f"Error fetching contacts: {response.status_code} - {response.text}")
                    self.update_status(f"Error fetching contacts: {response.status_code}")
                    break

                data = response.json()
                contacts = data.get('value', [])

                self.update_debug(f"Processing {len(contacts)} contacts...")

                for contact in contacts:
                    # Process display name
                    display_name = contact.get('displayName', '')
                    first_name, last_name = self._extract_name_parts(display_name)

                    # Extract company name
                    company = contact.get('companyName', '')

                    # Extract phone numbers
                    phone_numbers = []
                    if contact.get('homePhone'):
                        phone_numbers.append(contact.get('homePhone'))
                    if contact.get('mobilePhone'):
                        phone_numbers.append(contact.get('mobilePhone'))
                    if contact.get('businessPhones'):
                        phone_numbers.extend(contact.get('businessPhones'))

                    phone = ', '.join(phone_numbers) if phone_numbers else ''

                    # Process email addresses
                    email_addresses = contact.get('emailAddresses', [])
                    for email_info in email_addresses:
                        email = email_info.get('address', '').lower()
                        if email:
                            # If we don't have a good name from displayName, try to extract from email
                            if not first_name or not last_name:
                                name = email.split('@')[0].replace('.', ' ').title()
                                first_name, last_name = self._extract_name_parts(name)

                            # If no company name, try to extract from email domain
                            if not company:
                                company = self._extract_company_from_email(email)

                            self._add_contact(first_name, last_name, email, "Contacts", phone, company)
                            self.update_debug(f"Processed contact: {email} - Phone: {phone} - Company: {company}")

                    processed_contacts += 1

                # Update progress
                progress = 55 + 15 * (processed_contacts / 1000) if processed_contacts > 0 else 55
                self.update_progress(min(progress, 70))

                # Check for next page
                if '@odata.nextLink' in data:
                    url = data['@odata.nextLink']
                else:
                    url = None

            self.update_debug(f"Contacts extraction complete. Processed {processed_contacts} contacts.")

        except Exception as e:
            self.update_debug(f"Error extracting contacts: {str(e)}\n{traceback.format_exc()}")
            self.update_status(f"Error extracting contacts: {str(e)}")

    def extract_teams_data(self):
        """Extract names and emails from Teams channels"""
        self.update_status("Scanning Teams channels...")
        self.update_debug("Starting Teams channels extraction...")

        try:
            # Get joined teams
            url = f"{self.base_url}/me/joinedTeams"
            response = requests.get(url, headers=self.headers)

            if response.status_code != 200:
                self.update_debug(f"Error fetching Teams: {response.status_code} - {response.text}")
                self.update_status(f"Error fetching Teams: {response.status_code}")
                return

            teams = response.json().get('value', [])
            self.update_debug(f"Found {len(teams)} teams")

            for team in teams:
                team_id = team.get('id')
                team_name = team.get('displayName', 'Unknown Team')
                self.update_debug(f"Processing team: {team_name}")

                # Get channels in the team
                channels_url = f"{self.base_url}/teams/{team_id}/channels"
                channels_response = requests.get(channels_url, headers=self.headers)

                if channels_response.status_code == 200:
                    channels = channels_response.json().get('value', [])
                    self.update_debug(f"Found {len(channels)} channels in team {team_name}")

                    for channel in channels:
                        channel_id = channel.get('id')
                        channel_name = channel.get('displayName', 'Unknown Channel')
                        self.update_debug(f"Processing channel: {channel_name}")

                        # Get messages in the channel (limited to recent messages)
                        messages_url = f"{self.base_url}/teams/{team_id}/channels/{channel_id}/messages?$top=50"
                        messages_response = requests.get(messages_url, headers=self.headers)

                        if messages_response.status_code == 200:
                            messages = messages_response.json().get('value', [])
                            self.update_debug(f"Found {len(messages)} messages in channel {channel_name}")

                            for message in messages:
                                # Process sender
                                if 'from' in message and 'user' in message['from']:
                                    user = message['from']['user']
                                    email = user.get('email', '').lower()
                                    name = user.get('displayName', '')

                                    if email:
                                        first_name, last_name = self._extract_name_parts(name)

                                        # Extract company from email domain
                                        company = self._extract_company_from_email(email)

                                        self._add_contact(first_name, last_name, email,
                                                          f"Teams: {team_name}/{channel_name}", "", company)
                                        self.update_debug(f"Processed Teams user: {email}")

                                # Process message content for email patterns
                                if 'body' in message and 'content' in message['body']:
                                    self._extract_from_text(message['body']['content'],
                                                            f"Teams: {team_name}/{channel_name}")

                self.update_progress(80)  # Update progress for Teams

            self.update_debug("Teams channels extraction complete.")

        except Exception as e:
            self.update_debug(f"Error extracting Teams data: {str(e)}\n{traceback.format_exc()}")
            self.update_status(f"Error extracting Teams data: {str(e)}")

    def extract_teams_chats(self):
        """Extract names and emails from Teams 1:1 and group chats"""
        self.update_status("Scanning Teams chats...")
        self.update_debug("Starting Teams chats extraction...")

        try:
            # Get all chats
            url = f"{self.base_url}/me/chats?$expand=members&$top=50"

            while url:
                response = requests.get(url, headers=self.headers)

                if response.status_code != 200:
                    self.update_debug(f"Error fetching Teams chats: {response.status_code} - {response.text}")
                    self.update_status(f"Error fetching Teams chats: {response.status_code}")
                    break

                data = response.json()
                chats = data.get('value', [])

                self.update_debug(f"Processing {len(chats)} chats...")

                for chat in chats:
                    chat_type = chat.get('chatType', 'unknown')
                    chat_id = chat.get('id')
                    topic = chat.get('topic', 'No Topic')

                    if chat_type == 'oneOnOne':
                        chat_name = "1:1 Chat"
                    elif chat_type == 'group':
                        chat_name = f"Group Chat: {topic}"
                    elif chat_type == 'meeting':
                        chat_name = f"Meeting Chat: {topic}"
                    else:
                        chat_name = f"Chat: {topic}"

                    self.update_debug(f"Processing {chat_name} (ID: {chat_id})")

                    # Process chat members
                    members = chat.get('members', [])
                    for member in members:
                        if 'emailAddress' in member:
                            email = member['emailAddress'].get('address', '').lower()
                            name = member['emailAddress'].get('displayName', '')

                            if email:
                                first_name, last_name = self._extract_name_parts(name)

                                # Extract company from email domain
                                company = self._extract_company_from_email(email)

                                self._add_contact(first_name, last_name, email, f"Teams Chat: {chat_name}", "", company)
                                self.update_debug(f"Processed Teams chat member: {email}")

                    # Get messages in the chat
                    messages_url = f"{self.base_url}/me/chats/{chat_id}/messages?$top=50"
                    messages_response = requests.get(messages_url, headers=self.headers)

                    if messages_response.status_code == 200:
                        messages_data = messages_response.json()
                        messages = messages_data.get('value', [])

                        self.update_debug(f"Found {len(messages)} messages in {chat_name}")

                        for message in messages:
                            # Process sender
                            if 'from' in message and 'user' in message['from']:
                                user = message['from']['user']
                                email = user.get('email', '').lower()
                                name = user.get('displayName', '')

                                if email:
                                    first_name, last_name = self._extract_name_parts(name)

                                    # Extract company from email domain
                                    company = self._extract_company_from_email(email)

                                    self._add_contact(first_name, last_name, email, f"Teams Chat: {chat_name}", "",
                                                      company)
                                    self.update_debug(f"Processed Teams chat message sender: {email}")

                            # Process message content for email patterns
                            if 'body' in message and 'content' in message['body']:
                                self._extract_from_text(message['body']['content'], f"Teams Chat: {chat_name}")

                # Update progress
                progress = 80 + 10 * (len(chats) / 50) if len(chats) > 0 else 80
                self.update_progress(min(progress, 90))

                # Check for next page
                if '@odata.nextLink' in data:
                    url = data['@odata.nextLink']
                else:
                    url = None

            self.update_debug("Teams chats extraction complete.")

        except Exception as e:
            self.update_debug(f"Error extracting Teams chats: {str(e)}\n{traceback.format_exc()}")
            self.update_status(f"Error extracting Teams chats: {str(e)}")

    def _extract_from_text(self, text, source):
        """Extract names, emails, phone numbers, and company names from text content"""
        if not text:
            return

        # Extract emails using regex
        email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        emails = re.findall(email_pattern, text)

        self.update_debug(f"Found {len(emails)} emails in {source}")

        for email in emails:
            email = email.lower()
            # Try to find name near the email
            name = self._find_name_near_email(text, email)

            if not name:
                # If no name found, try to extract from email
                name = email.split('@')[0].replace('.', ' ').title()

            first_name, last_name = self._extract_name_parts(name)

            # Extract phone number
            phone = self._extract_phone_number(text)

            # Extract company name
            company = self._extract_company_name(text)

            # If no company found, try to extract from email domain
            if not company:
                company = self._extract_company_from_email(email)

            self._add_contact(first_name, last_name, email, source, phone, company)

    def _find_name_near_email(self, text, email):
        """Try to find a name near an email in text"""
        # Look for patterns like "First Last <email@domain.com>"
        name_email_pattern = r'([A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\s*<\s*' + re.escape(email) + r'\s*>'
        match = re.search(name_email_pattern, text)
        if match:
            return match.group(1)

        # Look for patterns like "First Last: email@domain.com"
        name_email_pattern2 = r'([A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\s*:\s*' + re.escape(email)
        match = re.search(name_email_pattern2, text)
        if match:
            return match.group(1)

        # Look for patterns like "email@domain.com - First Last"
        email_name_pattern = re.escape(email) + r'\s*[-]\s*([A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)'
        match = re.search(email_name_pattern, text)
        if match:
            return match.group(1)

        return None

    def _extract_name_parts(self, full_name):
        """Extract first and last name from a full name"""
        if not full_name:
            return "", ""

        # Remove common prefixes and suffixes
        name_parts = full_name.split()

        if len(name_parts) == 1:
            return name_parts[0], ""
        elif len(name_parts) == 2:
            return name_parts[0], name_parts[1]
        else:
            # For names with more than 2 parts, assume first part is first name and last part is last name
            return name_parts[0], name_parts[-1]

    def _add_contact(self, first_name, last_name, email, source, phone="", company=""):
        """Add a contact to the list if not already present"""
        # Check if email already exists
        for contact in self.contacts_data:
            if contact['Email'].lower() == email.lower():
                # Update source if new source is more specific
                if source and len(source) > len(contact.get('Source', '')):
                    contact['Source'] = source

                # Update phone if new phone is more complete and not a duplicate
                if phone and phone not in contact.get('Phone Number', ''):
                    if contact.get('Phone Number'):
                        # If existing phone is different, append the new one
                        contact['Phone Number'] = f"{contact['Phone Number']}, {phone}"
                    else:
                        # If no existing phone, just set it
                        contact['Phone Number'] = phone

                # Update company if new company is more complete
                if company and len(company) > len(contact.get('Company Name', '')):
                    contact['Company Name'] = company
                return

        # Add new contact
        self.contacts_data.append({
            'First Name': first_name,
            'Last Name': last_name,
            'Email': email,
            'Source': source,
            'Phone Number': phone,
            'Company Name': company
        })

    def extract_all_data(self, shared_mailboxes=None, scan_all_mailboxes=False):
        """Extract data from all sources"""
        self.contacts_data = []  # Reset contacts data

        # Extract from different sources
        self.extract_emails()

        # Extract from all mailboxes if requested
        if scan_all_mailboxes:
            self.extract_all_mailboxes()
        # Extract from shared mailboxes if provided
        elif shared_mailboxes:
            for mailbox in shared_mailboxes:
                self.extract_shared_mailbox_emails(mailbox)

        self.extract_calendar_events()
        self.extract_contacts()
        self.extract_teams_data()
        self.extract_teams_chats()  # New method for Teams chats

        # Deduplicate based on email
        self.update_status("Deduplicating data...")
        self._deduplicate_contacts()

        self.update_progress(100)  # Complete progress
        self.update_status("Scan complete!")

        return self.contacts_data

    def _deduplicate_contacts(self):
        """Remove duplicate contacts based on email"""
        seen_emails = set()
        unique_contacts = []

        for contact in self.contacts_data:
            email = contact['Email'].lower()
            if email not in seen_emails:
                seen_emails.add(email)
                unique_contacts.append(contact)

        self.contacts_data = unique_contacts


class LocalDataExtractor:
    """Handles extraction of contact data from local PST/OST files and other local sources"""

    def __init__(self):
        self.contacts_data = []
        self.progress_callback = None
        self.status_callback = None
        self.debug_callback = None
        self.file_paths = []
        self.scan_attachments = True
        self.scan_subfolders = True

    def set_callbacks(self, progress_callback, status_callback, debug_callback=None):
        """Set callbacks for progress, status, and debug updates"""
        self.progress_callback = progress_callback
        self.status_callback = status_callback
        self.debug_callback = debug_callback

    def update_status(self, message):
        """Update status message via callback"""
        if self.status_callback:
            self.status_callback(message)

    def update_progress(self, value):
        """Update progress bar via callback"""
        if self.progress_callback:
            self.progress_callback(value)

    def update_debug(self, message):
        """Update debug information via callback"""
        if self.debug_callback:
            self.debug_callback(message)

    def add_file_path(self, path):
        """Add a PST/OST file path to scan"""
        if os.path.exists(path) and (path.lower().endswith('.pst') or path.lower().endswith('.ost')):
            self.file_paths.append(path)
            return True
        return False

    def clear_file_paths(self):
        """Clear all PST/OST file paths"""
        self.file_paths = []

    def set_scan_options(self, scan_attachments=True, scan_subfolders=True):
        """Set scanning options"""
        self.scan_attachments = scan_attachments
        self.scan_subfolders = scan_subfolders

    def extract_all_data(self):
        """Extract data from all local sources"""
        self.contacts_data = []  # Reset contacts data

        # Scan PST/OST files
        if self.file_paths:
            self.update_status("Scanning PST/OST files...")
            for i, file_path in enumerate(self.file_paths):
                file_type = "PST" if file_path.lower().endswith('.pst') else "OST"
                self.update_status(
                    f"Scanning {file_type} file {i + 1}/{len(self.file_paths)}: {os.path.basename(file_path)}")
                self._scan_pst_ost_file(file_path)
                self.update_progress(25 * (i + 1) / len(self.file_paths))  # 25% of progress for PST/OST files

        # Scan local files for contact information
        self.update_status("Scanning local files...")
        self._scan_local_files()
        self.update_progress(50)  # 50% of progress for local files

        # Scan Outlook profile if available
        if COM_SUPPORT:
            self.update_status("Scanning Outlook profile...")
            self._scan_outlook_profile()
            self.update_progress(75)  # 75% of progress for Outlook profile

        # Deduplicate based on email
        self.update_status("Deduplicating data...")
        self._deduplicate_contacts()

        self.update_progress(100)  # Complete progress
        self.update_status("Local scan complete!")

        return self.contacts_data

    def _scan_pst_ost_file(self, file_path):
        """Scan a PST/OST file for contact information"""
        if not PST_SUPPORT:
            self.update_status("PST/OST support not available. Install libpff-win32 (Windows) or libpff (Linux/Mac)")
            return

        try:
            # Open the PST/OST file
            pst_file = pypff.file()
            pst_file.open(file_path)

            # Get the root folder
            root = pst_file.get_root_folder()

            # Scan all folders
            self._scan_pst_ost_folder(root, "Root")

            # Close the PST/OST file
            pst_file.close()

        except Exception as e:
            self.update_debug(f"Error scanning {file_path}: {str(e)}")
            self.update_status(f"Error scanning {file_path}: {str(e)}")

    def _scan_pst_ost_folder(self, folder, folder_name):
        """Recursively scan a PST/OST folder for emails"""
        try:
            # Get the number of subfolders and messages
            num_subfolders = folder.get_number_of_sub_folders()
            num_messages = folder.get_number_of_messages()

            self.update_debug(f"Scanning folder: {folder_name} ({num_messages} messages, {num_subfolders} subfolders)")

            # Process messages in this folder
            for message_index in range(num_messages):
                try:
                    message = folder.get_sub_message(message_index)
                    self._process_pst_ost_message(message, folder_name)
                except Exception as e:
                    self.update_debug(f"Error processing message in {folder_name}: {str(e)}")

            # Recursively process subfolders
            if self.scan_subfolders:
                for sub_folder_index in range(num_subfolders):
                    try:
                        sub_folder = folder.get_sub_folder(sub_folder_index)
                        sub_folder_name = f"{folder_name}/{sub_folder.get_name()}"
                        self._scan_pst_ost_folder(sub_folder, sub_folder_name)
                    except Exception as e:
                        self.update_debug(f"Error processing subfolder in {folder_name}: {str(e)}")

        except Exception as e:
            self.update_debug(f"Error scanning folder {folder_name}: {str(e)}")

    def _process_pst_ost_message(self, message, folder_name):
        """Process a PST/OST message to extract contact information"""
        try:
            # Process sender
            sender_email = message.get_sender_email_address()
            sender_name = message.get_subject()  # Using subject as fallback for name

            if sender_email:
                if not sender_name:
                    sender_name = sender_email.split('@')[0].replace('.', ' ').title()

                first_name, last_name = self._extract_name_parts(sender_name)

                # Extract company from email domain
                company = self._extract_company_from_email(sender_email)

                self._add_contact(first_name, last_name, sender_email, f"PST/OST: {folder_name}", "", company)
                self.update_debug(f"Processed sender: {sender_email}")

            # Process recipients
            num_recipients = message.get_number_of_recipients()
            for recipient_index in range(num_recipients):
                try:
                    recipient = message.get_recipient(recipient_index)
                    recipient_email = recipient.get_email_address()
                    recipient_name = recipient.get_name()

                    if recipient_email:
                        if not recipient_name:
                            recipient_name = recipient_email.split('@')[0].replace('.', ' ').title()

                        first_name, last_name = self._extract_name_parts(recipient_name)

                        # Extract company from email domain
                        company = self._extract_company_from_email(recipient_email)

                        self._add_contact(first_name, last_name, recipient_email, f"PST/OST: {folder_name}", "",
                                          company)
                        self.update_debug(f"Processed recipient: {recipient_email}")
                except Exception as e:
                    self.update_debug(f"Error processing recipient: {str(e)}")

            # Process body for email patterns
            try:
                body = message.get_plain_text_body()
                if body:
                    self._extract_from_text(body, f"PST/OST Body: {folder_name}")
                    self._extract_from_email_signature(body, f"PST/OST Signature: {folder_name}")
            except Exception as e:
                self.update_debug(f"Error processing message body: {str(e)}")

            # Process attachments
            if self.scan_attachments:
                try:
                    num_attachments = message.get_number_of_attachments()
                    for attachment_index in range(num_attachments):
                        attachment = message.get_attachment(attachment_index)
                        attachment_name = attachment.get_name()

                        # For simplicity, we'll just extract from the attachment name
                        # In a real implementation, you might want to parse the attachment content
                        if attachment_name:
                            self._extract_from_text(attachment_name, f"PST/OST Attachment: {folder_name}")
                except Exception as e:
                    self.update_debug(f"Error processing attachments: {str(e)}")

        except Exception as e:
            self.update_debug(f"Error processing PST/OST message: {str(e)}")

    # NEW: Improved signature extraction methods
    def _extract_from_email_signature(self, text, source):
        """Extracts names, emails, phone numbers, and company names from an email signature block."""
        if not text:
            return

        # Common patterns that precede a signature
        signature_delimiters = [
            r'(?:^|\n)--+\s*(?:\n|$)',
            r'(?:^|\n)---+\s*(?:\n|$)',
            r'(?:^|\n)(?:Thanks|Regards|Best regards|Sincerely|Cheers|Kind regards|Warm regards|Best|Cordially),?\s*(?:\n|$)',
        ]

        # Try to find ALL potential signature blocks
        signature_blocks = []

        for delimiter_pattern in signature_delimiters:
            matches = list(re.finditer(delimiter_pattern, text, re.IGNORECASE | re.MULTILINE))
            for match in matches:
                # Get text after delimiter (next 500 chars should be enough for a signature)
                start_pos = match.end()
                end_pos = min(start_pos + 500, len(text))
                signature_block = text[start_pos:end_pos].strip()

                if signature_block and len(signature_block) > 10:  # Ignore very short blocks
                    signature_blocks.append(signature_block)

        # If no signature blocks found, try to extract from the last 300 characters
        if not signature_blocks and len(text) > 300:
            signature_blocks.append(text[-300:])

        # Process each signature block
        for signature_block in signature_blocks:
            self._process_signature_block(signature_block, source)

    def _process_signature_block(self, signature_block, source):
        """Process a single signature block to extract contact information."""
        # Extract all emails from this block
        email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        emails = re.findall(email_pattern, signature_block)

        if not emails:
            return

        # Extract all phone numbers from this block
        phones = self._extract_all_phone_numbers(signature_block)

        # Extract all potential names from this block
        names = self._extract_all_names(signature_block)

        # Extract all potential company names from this block
        companies = self._extract_all_company_names(signature_block)

        # For each email found, try to associate it with nearby name, phone, and company
        for email in emails:
            email = email.lower()

            # Find the best matching name (closest to the email in the text)
            best_name = self._find_closest_match(signature_block, email, names)

            # Find the best matching phone (closest to the email in the text)
            best_phone = self._find_closest_match(signature_block, email, phones) if phones else ""

            # Find the best matching company (closest to the email in the text)
            best_company = self._find_closest_match(signature_block, email, companies) if companies else ""

            # If no company found, try to extract from email domain
            if not best_company:
                best_company = self._extract_company_from_email(email)

            # Extract first and last name
            if best_name:
                first_name, last_name = self._extract_name_parts(best_name)
            else:
                # Fall back to email-based name
                name = email.split('@')[0].replace('.', ' ').replace('_', ' ').title()
                first_name, last_name = self._extract_name_parts(name)

            # Add contact
            self._add_contact(first_name, last_name, email, source, best_phone, best_company)
            self.update_debug(
                f"Extracted from signature: {first_name} {last_name} - {email} - Phone: {best_phone} - Company: {best_company}"
            )

    def _extract_all_phone_numbers(self, text):
        """Extract all phone numbers from text using improved regex patterns."""
        phone_patterns = [
            r'\+?1?\s*\(?([0-9]{3})\)?[\s.-]?([0-9]{3})[\s.-]?([0-9]{4})',  # US/Canada
            r'\+([0-9]{1,3})\s*\(?([0-9]{1,4})\)?[\s.-]?([0-9]{3,4})[\s.-]?([0-9]{4})',  # International
        ]

        phones = []
        seen_normalized = set()  # Track normalized versions to avoid duplicates

        for pattern in phone_patterns:
            matches = re.finditer(pattern, text)
            for match in matches:
                phone = match.group(0).strip()

                # Normalize the phone number for duplicate detection
                # Remove all spaces, dashes, parentheses, and plus signs
                normalized = re.sub(r'[\s\-\(\)\+\.]', '', phone)

                # Skip if we've already found this number
                if normalized in seen_normalized:
                    continue

                # Skip if it's too short or too long
                if len(normalized) < 10 or len(normalized) > 15:
                    continue

                seen_normalized.add(normalized)

                # Format the phone number nicely
                phone = re.sub(r'\s+', ' ', phone)  # Normalize spaces
                phones.append(phone)

        return phones

    def _extract_all_names(self, text):
        """Extract all potential names from text."""
        # Look for capitalized words that could be names
        # This pattern looks for 2-4 consecutive capitalized words
        name_patterns = [
            r'\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,3})\b',  # John Smith, John Q. Smith, etc.
            r'\b([A-Z]\.\s*[A-Z][a-z]+)\b',  # J. Smith
            r'\b([A-Z][a-z]+\s+[A-Z]\.)\b',  # John S.
        ]

        names = []
        for pattern in name_patterns:
            matches = re.finditer(pattern, text)
            for match in matches:
                name = match.group(1).strip()
                # Filter out common words that aren't names
                if name and not any(word in name.lower() for word in
                                    ['the', 'and', 'for', 'with', 'from', 'office', 'mobile', 'phone', 'email',
                                     'direct']):
                    if name not in names:
                        names.append(name)

        return names

    def _extract_all_company_names(self, text):
        """Extract all potential company names from text with improved patterns."""
        company_patterns = [
            # Companies with legal suffixes (most reliable)
            r'\b([A-Z][A-Za-z0-9\s&]{1,50}?(?:Inc\.?|LLC|LLP|Ltd\.?|Co\.?|Corp\.?|Corporation|Company|GmbH|S\.A\.|SA|Pty\.?\s*Ltd\.?|Limited))\b',
            # Standalone business words (Group, International, etc.)
            r'\b([A-Z][A-Za-z0-9\s&]{2,40}?(?:Group|International|Solutions|Technologies|Systems|Partners|Associates|Enterprises|Consulting|Services))\b',
            # All-caps company names (common in signatures) - 2 to 6 words
            r'\b([A-Z]{2,}(?:\s+[A-Z]{2,}){0,5})\b',
            # Title case near signature indicators (like | or line breaks before contact info)
            r'(?:^|\n)([A-Z][a-z]+(?:\s+[A-Z][a-z]+){1,4})(?:\s*\n|\s*\|)',
        ]

        companies = []

        # Common words that indicate we've grabbed too much context
        context_words = [
            'if you need', 'in regard', 'related to', 'work for', 'working at',
            'employed by', 'anything urgent', 'please contact', 'feel free',
            'reach out', 'get in touch', 'let me know', 'thank you', 'thanks',
            'best regards', 'sincerely', 'kind regards', 'warm regards'
        ]

        for pattern in company_patterns:
            matches = re.finditer(pattern, text, re.MULTILINE)
            for match in matches:
                company = match.group(1).strip()

                # Clean up the company name
                company = re.sub(r'\s+', ' ', company)

                # Skip if it contains context words (these mean we grabbed surrounding text)
                if any(context_word in company.lower() for context_word in context_words):
                    # Try to extract just the company name from the context
                    # Look for the last capitalized sequence before the legal suffix
                    for sub_pattern in [r'([A-Z][A-Za-z\s&]{2,30}?(?:Inc\.?|LLC|LLP|Ltd\.?|Co\.?|Corp\.?)',
                                        r'([A-Z][A-Za-z\s&]{2,30}?(?:Group|International|Solutions|Technologies))']:
                        sub_match = re.search(sub_pattern, company)
                        if sub_match:
                            company = sub_match.group(1).strip()
                            break
                    else:
                        continue  # Skip this match if we can't extract clean company name

                # Filter out common false positives
                false_positives = ['phone', 'mobile', 'email', 'direct', 'office', 'cell',
                                   'street', 'avenue', 'road', 'drive', 'suite', 'floor',
                                   'dear', 'hello', 'hi there']

                if company and not any(word in company.lower() for word in false_positives):
                    # Must be between 3 and 60 characters
                    if 3 <= len(company) <= 60 and company not in companies:
                        companies.append(company)

        return companies

    def _find_closest_match(self, text, anchor, candidates):
        """Find the candidate closest to the anchor text in the string."""
        if not candidates:
            return ""

        anchor_pos = text.lower().find(anchor.lower())
        if anchor_pos == -1:
            return candidates[0] if candidates else ""

        closest = None
        min_distance = float('inf')

        for candidate in candidates:
            candidate_pos = text.find(candidate)
            if candidate_pos != -1:
                distance = abs(candidate_pos - anchor_pos)
                if distance < min_distance:
                    min_distance = distance
                    closest = candidate

        return closest if closest else (candidates[0] if candidates else "")

    def _extract_phone_number(self, text):
        """Extract the first phone number from text (kept for backward compatibility)."""
        phones = self._extract_all_phone_numbers(text)
        return phones[0] if phones else ""

    def _extract_company_name(self, text):
        """Extract the first company name from text (kept for backward compatibility)."""
        companies = self._extract_all_company_names(text)
        return companies[0] if companies else ""

    def _extract_company_from_email(self, email):
        """Extract company name from email domain with improved logic."""
        if not email or '@' not in email:
            return ""

        # Extract domain from email
        domain = email.split('@')[1].lower()

        # Skip common free email providers
        free_providers = [
            'gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com', 'aol.com',
            'icloud.com', 'live.com', 'msn.com', 'me.com', 'ymail.com',
            'protonmail.com', 'mail.com', 'zoho.com', 'gmx.com'
        ]

        if domain in free_providers:
            return ""

        # Remove common subdomains
        domain_parts = domain.split('.')
        if len(domain_parts) < 2:
            return ""

        # Remove common prefixes
        if domain_parts[0] in ['mail', 'www', 'email', 'smtp', 'exchange', 'webmail', 'portal']:
            domain_parts = domain_parts[1:]

        # Get the main domain (second-level domain)
        if len(domain_parts) >= 2:
            company = domain_parts[0]

            # Clean up the company name
            # Replace hyphens and underscores with spaces
            company = re.sub(r'[-_]', ' ', company)
            # Capitalize properly
            company = company.title()

            return company

        return ""

    def _scan_local_files(self):
        """Scan local files for contact information"""
        # Common locations for documents
        scan_paths = [
            os.path.expanduser("~/Documents"),
            os.path.expanduser("~/Desktop"),
            os.path.expanduser("~/Downloads")
        ]

        # File extensions to scan
        extensions = ['*.txt', '*.csv', '*.xlsx', '*.xls', '*.docx', '*.doc', '*.html', '*.htm']

        total_files = 0
        processed_files = 0

        # Count total files first for progress tracking
        for scan_path in scan_paths:
            if os.path.exists(scan_path):
                for ext in extensions:
                    total_files += len(glob.glob(os.path.join(scan_path, '**', ext), recursive=True))

        if total_files == 0:
            self.update_debug("No local files found to scan")
            return

        self.update_debug(f"Found {total_files} local files to scan")

        # Scan files
        for scan_path in scan_paths:
            if os.path.exists(scan_path):
                for ext in extensions:
                    for file_path in glob.glob(os.path.join(scan_path, '**', ext), recursive=True):
                        try:
                            self._scan_file(file_path)
                            processed_files += 1

                            # Update progress
                            progress = 50 + 25 * (processed_files / total_files)
                            self.update_progress(progress)

                        except Exception as e:
                            self.update_debug(f"Error scanning file {file_path}: {str(e)}")

    def _scan_file(self, file_path):
        """Scan a single file for contact information"""
        try:
            file_name = os.path.basename(file_path)
            file_ext = os.path.splitext(file_name)[1].lower()

            # Process Excel files
            if file_ext in ['.xlsx', '.xls']:
                try:
                    wb = load_workbook(file_path, read_only=True)

                    for sheet_name in wb.sheetnames:
                        sheet = wb[sheet_name]

                        for row in sheet.iter_rows(values_only=True):
                            row_text = ' '.join([str(cell) for cell in row if cell is not None])
                            self._extract_from_text(row_text, f"Local File: {file_name}")

                    wb.close()
                    self.update_debug(f"Processed Excel file: {file_name}")
                except Exception as e:
                    self.update_debug(f"Error processing Excel file {file_path}: {str(e)}")

            # Process text files
            elif file_ext in ['.txt', '.csv', '.html', '.htm']:
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                        self._extract_from_text(content, f"Local File: {file_name}")
                    self.update_debug(f"Processed text file: {file_name}")
                except Exception as e:
                    self.update_debug(f"Error processing text file {file_path}: {str(e)}")

            # Process Word documents (simplified - just extracting from filename)
            elif file_ext in ['.docx', '.doc']:
                # For simplicity, we'll just extract from the filename
                # In a real implementation, you might want to use python-docx to parse the content
                self._extract_from_text(file_name, f"Local File: {file_name}")
                self.update_debug(f"Processed Word file: {file_name}")

        except Exception as e:
            self.update_debug(f"Error scanning file {file_path}: {str(e)}")

    def _scan_outlook_profile(self):
        """Scan Outlook profile for contact information"""
        if not COM_SUPPORT:
            self.update_status("Windows COM support not available. Install pypiwin32")
            return

        try:
            # Create Outlook application object
            outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")

            # Get all folders
            folders = outlook.Folders

            self.update_debug(f"Found {len(folders)} Outlook folders")

            # Scan each folder
            for folder in folders:
                self._scan_outlook_folder(folder, "Outlook")

        except Exception as e:
            self.update_debug(f"Error scanning Outlook profile: {str(e)}")

    def _scan_outlook_folder(self, folder, folder_name):
        """Recursively scan an Outlook folder for emails"""
        try:
            # Get folder name
            current_folder_name = f"{folder_name}/{folder.Name}"

            # Process items in this folder
            items = folder.Items
            item_count = items.Count

            self.update_debug(f"Scanning Outlook folder: {current_folder_name} ({item_count} items)")

            for i in range(item_count):
                try:
                    item = items.Item(i + 1)
                    # Check if it's a mail item
                    if item.Class == 43:  # Mail item
                        self._process_outlook_email(item, current_folder_name)
                except Exception as e:
                    self.update_debug(f"Error processing Outlook item: {str(e)}")

            # Recursively process subfolders
            if self.scan_subfolders:
                for sub_folder in folder.Folders:
                    self._scan_outlook_folder(sub_folder, current_folder_name)

        except Exception as e:
            self.update_debug(f"Error scanning Outlook folder {folder_name}: {str(e)}")

    def _process_outlook_email(self, mail_item, folder_name):
        """Process an Outlook email to extract contact information"""
        try:
            # Process sender
            if mail_item.SenderEmailAddress:
                sender_email = mail_item.SenderEmailAddress.lower()
                sender_name = mail_item.SenderName

                if not sender_name:
                    sender_name = sender_email.split('@')[0].replace('.', ' ').title()

                first_name, last_name = self._extract_name_parts(sender_name)

                # Extract company from email domain
                company = self._extract_company_from_email(sender_email)

                self._add_contact(first_name, last_name, sender_email, f"Outlook: {folder_name}", "", company)
                self.update_debug(f"Processed Outlook sender: {sender_email}")

            # Process recipients
            if mail_item.Recipients:
                for recipient in mail_item.Recipients:
                    if recipient.Address:
                        recipient_email = recipient.Address.lower()
                        recipient_name = recipient.Name

                        if not recipient_name:
                            recipient_name = recipient_email.split('@')[0].replace('.', ' ').title()

                        first_name, last_name = self._extract_name_parts(recipient_name)

                        # Extract company from email domain
                        company = self._extract_company_from_email(recipient_email)

                        self._add_contact(first_name, last_name, recipient_email, f"Outlook: {folder_name}", "",
                                          company)
                        self.update_debug(f"Processed Outlook recipient: {recipient_email}")

            # Process body for email patterns
            if mail_item.Body:
                self._extract_from_text(mail_item.Body, f"Outlook Body: {folder_name}")
                self._extract_from_email_signature(mail_item.Body, f"Outlook Signature: {folder_name}")

            # Process attachments
            if self.scan_attachments and mail_item.Attachments:
                for attachment in mail_item.Attachments:
                    attachment_name = attachment.FileName

                    # For simplicity, we'll just extract from the attachment name
                    # In a real implementation, you might want to save and parse the attachment
                    if attachment_name:
                        self._extract_from_text(attachment_name, f"Outlook Attachment: {folder_name}")

        except Exception as e:
            self.update_debug(f"Error processing Outlook email: {str(e)}")

    def _extract_from_text(self, text, source):
        """Extract names, emails, phone numbers, and company names from text content"""
        if not text:
            return

        # Extract emails using regex
        email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        emails = re.findall(email_pattern, text)

        self.update_debug(f"Found {len(emails)} emails in {source}")

        for email in emails:
            email = email.lower()
            # Try to find name near the email
            name = self._find_name_near_email(text, email)

            if not name:
                # If no name found, try to extract from email
                name = email.split('@')[0].replace('.', ' ').title()

            first_name, last_name = self._extract_name_parts(name)

            # Extract phone number
            phone = self._extract_phone_number(text)

            # Extract company name
            company = self._extract_company_name(text)

            # If no company found, try to extract from email domain
            if not company:
                company = self._extract_company_from_email(email)

            self._add_contact(first_name, last_name, email, source, phone, company)

    def _find_name_near_email(self, text, email):
        """Try to find a name near an email in text"""
        # Look for patterns like "First Last <email@domain.com>"
        name_email_pattern = r'([A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\s*<\s*' + re.escape(email) + r'\s*>'
        match = re.search(name_email_pattern, text)
        if match:
            return match.group(1)

        # Look for patterns like "First Last: email@domain.com"
        name_email_pattern2 = r'([A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\s*:\s*' + re.escape(email)
        match = re.search(name_email_pattern2, text)
        if match:
            return match.group(1)

        # Look for patterns like "email@domain.com - First Last"
        email_name_pattern = re.escape(email) + r'\s*[-]\s*([A-Z][a-z]+\s+[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)'
        match = re.search(email_name_pattern, text)
        if match:
            return match.group(1)

        return None

    def _extract_name_parts(self, full_name):
        """Extract first and last name from a full name"""
        if not full_name:
            return "", ""

        # Remove common prefixes and suffixes
        name_parts = full_name.split()

        if len(name_parts) == 1:
            return name_parts[0], ""
        elif len(name_parts) == 2:
            return name_parts[0], name_parts[1]
        else:
            # For names with more than 2 parts, assume first part is first name and last part is last name
            return name_parts[0], name_parts[-1]

    def _add_contact(self, first_name, last_name, email, source, phone="", company=""):
        """Add a contact to the list if not already present"""
        # Check if email already exists
        for contact in self.contacts_data:
            if contact['Email'].lower() == email.lower():
                # Update source if new source is more specific
                if source and len(source) > len(contact.get('Source', '')):
                    contact['Source'] = source

                # Update phone if new phone is more complete and not a duplicate
                if phone and phone not in contact.get('Phone Number', ''):
                    if contact.get('Phone Number'):
                        # If existing phone is different, append the new one
                        contact['Phone Number'] = f"{contact['Phone Number']}, {phone}"
                    else:
                        # If no existing phone, just set it
                        contact['Phone Number'] = phone

                # Update company if new company is more complete
                if company and len(company) > len(contact.get('Company Name', '')):
                    contact['Company Name'] = company
                return

        # Add new contact
        self.contacts_data.append({
            'First Name': first_name,
            'Last Name': last_name,
            'Email': email,
            'Source': source,
            'Phone Number': phone,
            'Company Name': company
        })

    def _deduplicate_contacts(self):
        """Remove duplicate contacts based on email"""
        seen_emails = set()
        unique_contacts = []

        for contact in self.contacts_data:
            email = contact['Email'].lower()
            if email not in seen_emails:
                seen_emails.add(email)
                unique_contacts.append(contact)

        self.contacts_data = unique_contacts


class ModernButton(tk.Canvas):
    """Custom modern button with hover effects"""

    def __init__(self, parent, text, command, theme, **kwargs):
        self.theme = theme
        width = kwargs.pop('width', 120)
        height = kwargs.pop('height', 36)

        super().__init__(parent, width=width, height=height,
                         bg=theme['bg'], highlightthickness=0, **kwargs)

        self.command = command
        self.text = text
        self.is_hover = False

        # Draw button
        self.draw_button()

        # Bind events
        self.bind('<Button-1>', self.on_click)
        self.bind('<Enter>', self.on_enter)
        self.bind('<Leave>', self.on_leave)

    def draw_button(self):
        self.delete('all')
        color = self.theme['button_active'] if self.is_hover else self.theme['button_bg']

        # Rounded rectangle
        self.create_rounded_rect(2, 2, self.winfo_reqwidth() - 2,
                                 self.winfo_reqheight() - 2, 8, fill=color, outline='')

        # Text
        self.create_text(self.winfo_reqwidth() // 2, self.winfo_reqheight() // 2,
                         text=self.text, fill=self.theme['button_fg'],
                         font=('Segoe UI', 10, 'bold'))

    def create_rounded_rect(self, x1, y1, x2, y2, radius, **kwargs):
        points = [
            x1 + radius, y1,
            x2 - radius, y1,
            x2, y1,
            x2, y1 + radius,
            x2, y2 - radius,
            x2, y2,
            x2 - radius, y2,
            x1 + radius, y2,
            x1, y2,
            x1, y2 - radius,
            x1, y1 + radius,
            x1, y1
        ]
        return self.create_polygon(points, smooth=True, **kwargs)

    def on_click(self, event):
        if self.command:
            self.command()

    def on_enter(self, event):
        self.is_hover = True
        self.draw_button()

    def on_leave(self, event):
        self.is_hover = False
        self.draw_button()

    def update_theme(self, theme):
        self.theme = theme
        self.config(bg=theme['bg'])
        self.draw_button()


class ContactExtractorApp:
    """Main application class for the Contact Extractor"""

    def __init__(self, root):
        self.root = root
        self.root.title("Contact Extractor Pro")
        self.root.geometry("1200x900")
        self.root.resizable(True, True)

        # Initialize variables
        self.access_token = None
        self.data = []
        self.extraction_thread = None
        self.token_cache = msal.SerializableTokenCache()
        self.mode = "online"

        # Load theme
        self.current_theme_name = config_values.get('theme', 'dark')
        self.theme = THEMES[self.current_theme_name]

        # Apply theme to root
        self.root.config(bg=self.theme['bg'])

        # Load initial configuration
        self.load_gui_config()

        # Create main container
        self.create_main_container()

        # Create GUI
        self.create_widgets()

        # Check if CLIENT_ID and TENANT_ID are configured
        self.check_configuration()

    def create_main_container(self):
        """Create the main scrollable container"""
        # Main canvas with custom scrollbar
        self.main_canvas = tk.Canvas(self.root, bg=self.theme['bg'],
                                     highlightthickness=0)

        # Custom scrollbar
        scrollbar_frame = tk.Frame(self.root, bg=self.theme['bg'], width=14)
        self.scrollbar = tk.Canvas(scrollbar_frame, bg=self.theme['scrollbar'],
                                   width=8, highlightthickness=0)
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y, padx=3)

        self.scrollable_frame = tk.Frame(self.main_canvas, bg=self.theme['bg'])

        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.main_canvas.configure(scrollregion=self.main_canvas.bbox("all"))
        )

        self.main_canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.main_canvas.configure(yscrollcommand=self._on_canvas_scroll)

        self.main_canvas.pack(side="left", fill="both", expand=True)
        scrollbar_frame.pack(side="right", fill="y")

        # Bind mousewheel
        self.main_canvas.bind_all("<MouseWheel>", self._on_mousewheel)

    def _on_canvas_scroll(self, *args):
        """Update custom scrollbar position"""
        self.scrollbar.delete('all')
        if len(args) == 2:
            start, end = float(args[0]), float(args[1])
            height = self.scrollbar.winfo_height()
            bar_height = max(30, height * (end - start))
            bar_y = height * start

            self.scrollbar.create_rectangle(0, bar_y, 8, bar_y + bar_height,
                                            fill=self.theme['scrollbar_active'],
                                            outline='')

    def _on_mousewheel(self, event):
        """Handle mouse wheel scrolling"""
        self.main_canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

    def load_gui_config(self):
        """Loads configuration and updates global variables."""
        global CLIENT_ID, TENANT_ID, AUTHORITY
        config_values = load_config()
        CLIENT_ID = config_values['client_id']
        TENANT_ID = config_values['tenant_id']
        AUTHORITY = f"https://login.microsoftonline.com/{TENANT_ID}"

    def create_modern_frame(self, parent, title, **kwargs):
        """Create a modern styled frame"""
        container = tk.Frame(parent, bg=self.theme['bg'])

        # Title bar
        title_frame = tk.Frame(container, bg=self.theme['accent'], height=40)
        title_frame.pack(fill=tk.X)
        title_frame.pack_propagate(False)

        title_label = tk.Label(title_frame, text=title,
                               bg=self.theme['accent'],
                               fg=self.theme['button_fg'],
                               font=('Segoe UI', 11, 'bold'))
        title_label.pack(side=tk.LEFT, padx=15, pady=10)

        # Content frame
        content = tk.Frame(container, bg=self.theme['frame_bg'],
                           relief=tk.FLAT, bd=0)
        content.pack(fill=tk.BOTH, expand=True, padx=1, pady=(0, 1))

        # Add padding
        padded_content = tk.Frame(content, bg=self.theme['frame_bg'])
        padded_content.pack(fill=tk.BOTH, expand=True, padx=20, pady=15)

        return container, padded_content

    def create_modern_entry(self, parent, textvariable, show=None, **kwargs):
        """Create a modern styled entry"""
        entry = tk.Entry(parent, textvariable=textvariable,
                         bg=self.theme['entry_bg'],
                         fg=self.theme['entry_fg'],
                         insertbackground=self.theme['accent'],
                         relief=tk.FLAT,
                         font=('Segoe UI', 10),
                         bd=0,
                         show=show if show else '')

        # Add padding
        entry.config(highlightthickness=1,
                     highlightbackground=self.theme['border'],
                     highlightcolor=self.theme['accent'])

        return entry

    def create_widgets(self):
        """Create all GUI widgets"""
        # Header with theme toggle
        header = tk.Frame(self.scrollable_frame, bg=self.theme['accent'], height=60)
        header.pack(fill=tk.X, pady=(0, 20))
        header.pack_propagate(False)

        title_label = tk.Label(header, text=" Contact Extractor Pro",
                               font=('Segoe UI', 20, 'bold'),
                               bg=self.theme['accent'],
                               fg=self.theme['button_fg'])
        title_label.pack(side=tk.LEFT, padx=20)

        # Theme toggle button
        theme_icon = "" if self.current_theme_name == 'light' else ""
        self.theme_button = ModernButton(header, theme_icon,
                                         self.toggle_theme, self.theme,
                                         width=50, height=40)
        self.theme_button.pack(side=tk.RIGHT, padx=20)

        # Mode selection frame
        mode_container, mode_content = self.create_modern_frame(
            self.scrollable_frame, " Mode Selection")
        mode_container.pack(fill=tk.X, pady=(0, 15), padx=20)

        mode_text = tk.Label(mode_content,
                             text="Select the mode you want to use for data extraction:",
                             bg=self.theme['frame_bg'],
                             fg=self.theme['label_fg'],
                             font=('Segoe UI', 10))
        mode_text.pack(anchor=tk.W, pady=(0, 10))

        mode_button_frame = tk.Frame(mode_content, bg=self.theme['frame_bg'])
        mode_button_frame.pack(fill=tk.X)

        self.mode_var = tk.StringVar(value="online")

        # Custom radio buttons
        self.online_radio_frame = self.create_radio_button(
            mode_button_frame, "Online Mode (Azure AD)",
            self.mode_var, "online", self.switch_mode)
        self.online_radio_frame.pack(side=tk.LEFT, padx=(0, 20))

        self.local_radio_frame = self.create_radio_button(
            mode_button_frame, "Local Mode (PST/OST Files)",
            self.mode_var, "local", self.switch_mode)
        self.local_radio_frame.pack(side=tk.LEFT)

        # Configuration frame
        self.config_container, self.config_content = self.create_modern_frame(
            self.scrollable_frame, " Configuration")
        self.config_container.pack(fill=tk.X, pady=(0, 15), padx=20)

        # Online mode configuration
        self.online_config_frame = tk.Frame(self.config_content,
                                            bg=self.theme['frame_bg'])

        # Azure AD Credentials
        azure_label = tk.Label(self.online_config_frame,
                               text="Azure AD Credentials",
                               bg=self.theme['frame_bg'],
                               fg=self.theme['fg'],
                               font=('Segoe UI', 10, 'bold'))
        azure_label.pack(anchor=tk.W, pady=(0, 10))

        # Client ID
        client_id_label = tk.Label(self.online_config_frame,
                                   text="Application (Client) ID:",
                                   bg=self.theme['frame_bg'],
                                   fg=self.theme['label_fg'],
                                   font=('Segoe UI', 9))
        client_id_label.pack(anchor=tk.W, pady=(0, 5))

        client_id_frame = tk.Frame(self.online_config_frame,
                                   bg=self.theme['frame_bg'])
        client_id_frame.pack(fill=tk.X, pady=(0, 10))

        self.client_id_var = tk.StringVar(value=CLIENT_ID)
        self.client_id_entry = self.create_modern_entry(
            client_id_frame, self.client_id_var, show="*")
        self.client_id_entry.pack(side=tk.LEFT, fill=tk.X, expand=True,
                                  ipady=8, padx=(0, 10))

        self.show_client_id_button = ModernButton(
            client_id_frame, "Show",
            lambda: self.toggle_password_visibility(
                self.client_id_entry, self.show_client_id_button),
            self.theme, width=80)
        self.show_client_id_button.pack(side=tk.LEFT)

        # Tenant ID
        tenant_id_label = tk.Label(self.online_config_frame,
                                   text="Directory (Tenant) ID:",
                                   bg=self.theme['frame_bg'],
                                   fg=self.theme['label_fg'],
                                   font=('Segoe UI', 9))
        tenant_id_label.pack(anchor=tk.W, pady=(0, 5))

        tenant_id_frame = tk.Frame(self.online_config_frame,
                                   bg=self.theme['frame_bg'])
        tenant_id_frame.pack(fill=tk.X, pady=(0, 10))

        self.tenant_id_var = tk.StringVar(value=TENANT_ID)
        self.tenant_id_entry = self.create_modern_entry(
            tenant_id_frame, self.tenant_id_var, show="*")
        self.tenant_id_entry.pack(side=tk.LEFT, fill=tk.X, expand=True,
                                  ipady=8, padx=(0, 10))

        self.show_tenant_id_button = ModernButton(
            tenant_id_frame, "Show",
            lambda: self.toggle_password_visibility(
                self.tenant_id_entry, self.show_tenant_id_button),
            self.theme, width=80)
        self.show_tenant_id_button.pack(side=tk.LEFT)

        save_config_button = ModernButton(self.online_config_frame,
                                          " Save Configuration",
                                          self.save_gui_config, self.theme,
                                          width=160)
        save_config_button.pack(anchor=tk.W, pady=(10, 15))

        # Date range
        date_label = tk.Label(self.online_config_frame,
                              text="Date and Time Range",
                              bg=self.theme['frame_bg'],
                              fg=self.theme['fg'],
                              font=('Segoe UI', 10, 'bold'))
        date_label.pack(anchor=tk.W, pady=(10, 10))

        date_grid = tk.Frame(self.online_config_frame, bg=self.theme['frame_bg'])
        date_grid.pack(fill=tk.X, pady=(0, 10))

        # Start date
        start_label = tk.Label(date_grid, text="Start:",
                               bg=self.theme['frame_bg'],
                               fg=self.theme['label_fg'],
                               font=('Segoe UI', 9))
        start_label.grid(row=0, column=0, sticky=tk.W, padx=(0, 10))

        self.start_date_var = tk.StringVar(
            value=(datetime.now() - timedelta(days=365)).strftime("%Y-%m-%d %H:%M"))
        self.start_date_entry = self.create_modern_entry(
            date_grid, self.start_date_var)
        self.start_date_entry.grid(row=0, column=1, sticky=tk.EW, ipady=8)

        # End date
        end_label = tk.Label(date_grid, text="End:",
                             bg=self.theme['frame_bg'],
                             fg=self.theme['label_fg'],
                             font=('Segoe UI', 9))
        end_label.grid(row=1, column=0, sticky=tk.W, padx=(0, 10), pady=(10, 0))

        self.end_date_var = tk.StringVar(
            value=datetime.now().strftime("%Y-%m-%d %H:%M"))
        self.end_date_entry = self.create_modern_entry(
            date_grid, self.end_date_var)
        self.end_date_entry.grid(row=1, column=1, sticky=tk.EW, ipady=8, pady=(10, 0))

        date_grid.columnconfigure(1, weight=1)

        # Quick range buttons
        quick_frame = tk.Frame(self.online_config_frame, bg=self.theme['frame_bg'])
        quick_frame.pack(fill=tk.X, pady=(10, 0))

        quick_label = tk.Label(quick_frame, text="Quick Ranges:",
                               bg=self.theme['frame_bg'],
                               fg=self.theme['label_fg'],
                               font=('Segoe UI', 9))
        quick_label.pack(side=tk.LEFT, padx=(0, 10))

        for days, label in [(7, "7 Days"), (30, "30 Days"), (90, "90 Days"), (365, "1 Year")]:
            btn = ModernButton(quick_frame, label,
                               lambda d=days: self.set_quick_range(d),
                               self.theme, width=80)
            btn.pack(side=tk.LEFT, padx=5)

        # Mailbox selection
        mailbox_label = tk.Label(self.online_config_frame,
                                 text="Mailbox Selection",
                                 bg=self.theme['frame_bg'],
                                 fg=self.theme['fg'],
                                 font=('Segoe UI', 10, 'bold'))
        mailbox_label.pack(anchor=tk.W, pady=(15, 10))

        self.mailbox_option_var = tk.StringVar(value="personal")

        mailbox_radios = tk.Frame(self.online_config_frame, bg=self.theme['frame_bg'])
        mailbox_radios.pack(fill=tk.X, pady=(0, 10))

        self.personal_mailbox_radio = self.create_radio_button(
            mailbox_radios, "My mailbox only",
            self.mailbox_option_var, "personal", self.update_mailbox_selection)
        self.personal_mailbox_radio.pack(anchor=tk.W, pady=5)

        self.all_mailboxes_radio = self.create_radio_button(
            mailbox_radios, "All mailboxes in organization",
            self.mailbox_option_var, "all", self.update_mailbox_selection)
        self.all_mailboxes_radio.pack(anchor=tk.W, pady=5)

        self.shared_mailboxes_radio = self.create_radio_button(
            mailbox_radios, "Specific shared mailboxes",
            self.mailbox_option_var, "shared", self.update_mailbox_selection)
        self.shared_mailboxes_radio.pack(anchor=tk.W, pady=5)

        # Shared mailboxes frame
        self.shared_mailboxes_frame = tk.Frame(self.online_config_frame,
                                               bg=self.theme['frame_bg'])

        listbox_frame = tk.Frame(self.shared_mailboxes_frame,
                                 bg=self.theme['entry_bg'],
                                 highlightthickness=1,
                                 highlightbackground=self.theme['border'])
        listbox_frame.pack(fill=tk.X, pady=(5, 10))

        self.mailboxes_listbox = tk.Listbox(listbox_frame, height=4,
                                            bg=self.theme['entry_bg'],
                                            fg=self.theme['entry_fg'],
                                            selectbackground=self.theme['accent'],
                                            relief=tk.FLAT, bd=0,
                                            font=('Segoe UI', 9))
        self.mailboxes_listbox.pack(fill=tk.X, padx=5, pady=5)

        mailbox_btns = tk.Frame(self.shared_mailboxes_frame,
                                bg=self.theme['frame_bg'])
        mailbox_btns.pack(fill=tk.X)

        add_mb_btn = ModernButton(mailbox_btns, " Add Mailbox",
                                  self.add_mailbox, self.theme, width=130)
        add_mb_btn.pack(side=tk.LEFT, padx=(0, 10))

        remove_mb_btn = ModernButton(mailbox_btns, " Remove",
                                     self.remove_mailbox, self.theme, width=100)
        remove_mb_btn.pack(side=tk.LEFT)

        # Outbound only option
        outbound_frame = tk.Frame(self.online_config_frame,
                                  bg=self.theme['frame_bg'])
        outbound_frame.pack(fill=tk.X, pady=(15, 0))

        self.outbound_only_var = tk.BooleanVar(value=False)
        self.outbound_check = self.create_checkbox(
            outbound_frame, "Scan outbound emails only (sent items)",
            self.outbound_only_var)
        self.outbound_check.pack(anchor=tk.W)

        # Local mode configuration
        self.local_config_frame = tk.Frame(self.config_content,
                                           bg=self.theme['frame_bg'])

        local_label = tk.Label(self.local_config_frame,
                               text="PST/OST Files",
                               bg=self.theme['frame_bg'],
                               fg=self.theme['fg'],
                               font=('Segoe UI', 10, 'bold'))
        local_label.pack(anchor=tk.W, pady=(0, 10))

        file_listbox_frame = tk.Frame(self.local_config_frame,
                                      bg=self.theme['entry_bg'],
                                      highlightthickness=1,
                                      highlightbackground=self.theme['border'])
        file_listbox_frame.pack(fill=tk.X, pady=(0, 10))

        self.file_listbox = tk.Listbox(file_listbox_frame, height=4,
                                       bg=self.theme['entry_bg'],
                                       fg=self.theme['entry_fg'],
                                       selectbackground=self.theme['accent'],
                                       relief=tk.FLAT, bd=0,
                                       font=('Segoe UI', 9))
        self.file_listbox.pack(fill=tk.X, padx=5, pady=5)

        file_btns = tk.Frame(self.local_config_frame, bg=self.theme['frame_bg'])
        file_btns.pack(fill=tk.X)

        add_file_btn = ModernButton(file_btns, " Add File",
                                    self.add_file, self.theme, width=110)
        add_file_btn.pack(side=tk.LEFT, padx=(0, 10))

        remove_file_btn = ModernButton(file_btns, " Remove",
                                       self.remove_file, self.theme, width=100)
        remove_file_btn.pack(side=tk.LEFT)

        # Scan options
        scan_opts_label = tk.Label(self.local_config_frame,
                                   text="Scan Options",
                                   bg=self.theme['frame_bg'],
                                   fg=self.theme['fg'],
                                   font=('Segoe UI', 10, 'bold'))
        scan_opts_label.pack(anchor=tk.W, pady=(15, 10))

        self.scan_attachments_var = tk.BooleanVar(value=True)
        self.scan_att_check = self.create_checkbox(
            self.local_config_frame, "Scan attachments",
            self.scan_attachments_var)
        self.scan_att_check.pack(anchor=tk.W, pady=5)

        self.scan_subfolders_var = tk.BooleanVar(value=True)
        self.scan_sub_check = self.create_checkbox(
            self.local_config_frame, "Scan subfolders",
            self.scan_subfolders_var)
        self.scan_sub_check.pack(anchor=tk.W, pady=5)

        # Authentication frame
        self.auth_container, self.auth_content = self.create_modern_frame(
            self.scrollable_frame, " Authentication")
        self.auth_container.pack(fill=tk.X, pady=(0, 15), padx=20)

        self.auth_status_label = tk.Label(self.auth_content,
                                          text="Status: Not configured",
                                          bg=self.theme['frame_bg'],
                                          fg=self.theme['warning'],
                                          font=('Segoe UI', 10))
        self.auth_status_label.pack(anchor=tk.W)

        # Progress frame
        progress_container, progress_content = self.create_modern_frame(
            self.scrollable_frame, " Scan Progress")
        progress_container.pack(fill=tk.X, pady=(0, 15), padx=20)

        self.progress_var = tk.DoubleVar()

        # Custom progress bar
        progress_bg = tk.Frame(progress_content, bg=self.theme['border'],
                               height=30)
        progress_bg.pack(fill=tk.X, pady=(0, 10))

        self.progress_fill = tk.Frame(progress_bg, bg=self.theme['accent'],
                                      height=30)
        self.progress_fill.place(relx=0, rely=0, relheight=1, relwidth=0)

        self.progress_text = tk.Label(progress_bg, text="0%",
                                      bg=self.theme['accent'],
                                      fg=self.theme['button_fg'],
                                      font=('Segoe UI', 9, 'bold'))
        self.progress_text.place(relx=0.5, rely=0.5, anchor=tk.CENTER)

        self.status_label = tk.Label(progress_content,
                                     text="Ready to start scanning",
                                     bg=self.theme['frame_bg'],
                                     fg=self.theme['label_fg'],
                                     font=('Segoe UI', 9))
        self.status_label.pack(anchor=tk.W)

        # Action buttons
        action_frame = tk.Frame(self.scrollable_frame, bg=self.theme['bg'])
        action_frame.pack(fill=tk.X, pady=(0, 15), padx=20)

        self.start_button = ModernButton(action_frame, " Start Scan",
                                         self.start_scan, self.theme, width=140)
        self.start_button.pack(side=tk.LEFT, padx=(0, 10))

        self.auth_button = ModernButton(action_frame, " Authenticate",
                                        self.authenticate, self.theme, width=140)

        self.clear_cache_button = ModernButton(action_frame, " Clear Cache",
                                               self.clear_cache, self.theme, width=130)

        self.clear_config_button = ModernButton(action_frame, " Clear IDs",
                                                self.clear_config, self.theme, width=120)

        self.debug_button = ModernButton(action_frame, " Debug Info",
                                         self.show_debug_info, self.theme, width=130)
        self.debug_button.pack(side=tk.LEFT, padx=(0, 10))

        self.config_button = ModernButton(action_frame, " Help",
                                          self.show_config_help, self.theme, width=100)
        self.config_button.pack(side=tk.LEFT)

        # Results frame
        results_container, results_content = self.create_modern_frame(
            self.scrollable_frame, " Results")
        results_container.pack(fill=tk.BOTH, expand=True, pady=(0, 15), padx=20)

        # Custom styled text widget
        text_frame = tk.Frame(results_content, bg=self.theme['entry_bg'],
                              highlightthickness=1,
                              highlightbackground=self.theme['border'])
        text_frame.pack(fill=tk.BOTH, expand=True)

        self.results_text = tk.Text(text_frame, height=15, wrap=tk.WORD,
                                    bg=self.theme['entry_bg'],
                                    fg=self.theme['entry_fg'],
                                    relief=tk.FLAT, bd=0,
                                    font=('Consolas', 9),
                                    padx=10, pady=10)

        results_scroll = tk.Scrollbar(text_frame, command=self.results_text.yview,
                                      bg=self.theme['scrollbar'])
        self.results_text.config(yscrollcommand=results_scroll.set)

        self.results_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        results_scroll.pack(side=tk.RIGHT, fill=tk.Y)

        # Export buttons
        export_frame = tk.Frame(self.scrollable_frame, bg=self.theme['bg'])
        export_frame.pack(fill=tk.X, padx=20, pady=(0, 20))

        self.export_excel_button = ModernButton(
            export_frame, " Export to Excel",
            lambda: self.export_data("excel"), self.theme, width=160)
        self.export_excel_button.pack(side=tk.LEFT, padx=(0, 10))
        self.export_excel_button.config(state='disabled')

        self.export_csv_button = ModernButton(
            export_frame, " Export to CSV",
            lambda: self.export_data("csv"), self.theme, width=150)
        self.export_csv_button.pack(side=tk.LEFT, padx=(0, 10))
        self.export_csv_button.config(state='disabled')

        self.export_html_button = ModernButton(
            export_frame, " Export to HTML",
            lambda: self.export_data("html"), self.theme, width=160)
        self.export_html_button.pack(side=tk.LEFT)
        self.export_html_button.config(state='disabled')

        # Set initial mode display
        if self.mode_var.get() == "online":
            self.online_config_frame.pack(fill=tk.X)
            self.auth_button.pack(side=tk.LEFT, padx=(0, 10))
            self.clear_cache_button.pack(side=tk.LEFT, padx=(0, 10))
            self.clear_config_button.pack(side=tk.LEFT, padx=(0, 10))
            self.check_configuration()
        else:
            self.local_config_frame.pack(fill=tk.X)
            self.auth_container.pack_forget()

    def create_radio_button(self, parent, text, variable, value, command):
        """Create a custom styled radio button"""
        frame = tk.Frame(parent, bg=self.theme['frame_bg'])

        canvas = tk.Canvas(frame, width=20, height=20,
                           bg=self.theme['frame_bg'],
                           highlightthickness=0)
        canvas.pack(side=tk.LEFT, padx=(0, 8))

        label = tk.Label(frame, text=text,
                         bg=self.theme['frame_bg'],
                         fg=self.theme['fg'],
                         font=('Segoe UI', 10))
        label.pack(side=tk.LEFT)

        def update_radio():
            variable.set(value)
            command()
            self.update_all_radios()

        canvas.bind('<Button-1>', lambda e: update_radio())
        label.bind('<Button-1>', lambda e: update_radio())

        # Store canvas for later updates
        frame.radio_canvas = canvas
        frame.radio_value = value
        frame.radio_var = variable

        self.draw_radio(canvas, variable.get() == value)

        return frame

    def draw_radio(self, canvas, selected):
        """Draw radio button state"""
        canvas.delete('all')
        # Outer circle
        canvas.create_oval(2, 2, 18, 18,
                           outline=self.theme['accent'],
                           width=2)
        # Inner circle if selected
        if selected:
            canvas.create_oval(6, 6, 14, 14,
                               fill=self.theme['accent'],
                               outline='')

    def update_all_radios(self):
        """Update all radio button displays"""
        for widget in [self.online_radio_frame, self.local_radio_frame,
                       self.personal_mailbox_radio, self.all_mailboxes_radio,
                       self.shared_mailboxes_radio]:
            if hasattr(widget, 'radio_canvas'):
                self.draw_radio(widget.radio_canvas,
                                widget.radio_var.get() == widget.radio_value)

    def create_checkbox(self, parent, text, variable):
        """Create a custom styled checkbox"""
        frame = tk.Frame(parent, bg=self.theme['frame_bg'])

        canvas = tk.Canvas(frame, width=20, height=20,
                           bg=self.theme['frame_bg'],
                           highlightthickness=0)
        canvas.pack(side=tk.LEFT, padx=(0, 8))

        label = tk.Label(frame, text=text,
                         bg=self.theme['frame_bg'],
                         fg=self.theme['fg'],
                         font=('Segoe UI', 10))
        label.pack(side=tk.LEFT)

        def toggle():
            variable.set(not variable.get())
            self.draw_checkbox(canvas, variable.get())

        canvas.bind('<Button-1>', lambda e: toggle())
        label.bind('<Button-1>', lambda e: toggle())

        self.draw_checkbox(canvas, variable.get())

        # Store reference for updates
        frame.check_canvas = canvas
        frame.check_var = variable

        return frame

    def draw_checkbox(self, canvas, checked):
        """Draw checkbox state"""
        canvas.delete('all')
        # Box
        canvas.create_rectangle(2, 2, 18, 18,
                                outline=self.theme['accent'],
                                width=2)
        # Checkmark if checked
        if checked:
            canvas.create_line(5, 10, 9, 14, fill=self.theme['accent'], width=2)
            canvas.create_line(9, 14, 16, 5, fill=self.theme['accent'], width=2)

    def toggle_theme(self):
        """Toggle between dark and light themes"""
        self.current_theme_name = 'light' if self.current_theme_name == 'dark' else 'dark'
        self.theme = THEMES[self.current_theme_name]

        # Save theme preference
        save_config(CLIENT_ID, TENANT_ID, self.current_theme_name)

        # Update all widgets
        self.apply_theme_to_all_widgets()

        # Update theme button icon
        theme_icon = "" if self.current_theme_name == 'light' else ""
        self.theme_button.text = theme_icon
        self.theme_button.update_theme(self.theme)

    def apply_theme_to_all_widgets(self):
        """Apply current theme to all widgets"""
        self.root.config(bg=self.theme['bg'])
        self.main_canvas.config(bg=self.theme['bg'])
        self.scrollable_frame.config(bg=self.theme['bg'])
        self.scrollbar.config(bg=self.theme['scrollbar'])

        # Recursively update all widgets
        def update_widget(widget):
            try:
                widget_type = widget.winfo_class()

                if widget_type == 'Frame':
                    if 'bg' in widget.keys():
                        current_bg = str(widget['bg'])
                        # Update based on what type of frame it is
                        if any(old in current_bg for old in ['#1e1e1e', '#f5f5f5']):
                            widget.config(bg=self.theme['bg'])
                        elif any(old in current_bg for old in ['#2d2d2d', '#ffffff', '#252525', '#fafafa']):
                            widget.config(bg=self.theme['frame_bg'])
                        elif any(old in current_bg for old in ['#0d7377']):
                            widget.config(bg=self.theme['accent'])

                elif widget_type == 'Label':
                    if 'bg' in widget.keys():
                        current_bg = str(widget['bg'])
                        if any(old in current_bg for old in ['#1e1e1e', '#f5f5f5']):
                            widget.config(bg=self.theme['bg'], fg=self.theme['fg'])
                        elif any(old in current_bg for old in ['#2d2d2d', '#ffffff', '#252525', '#fafafa']):
                            widget.config(bg=self.theme['frame_bg'], fg=self.theme['fg'])
                        elif any(old in current_bg for old in ['#0d7377']):
                            widget.config(bg=self.theme['accent'], fg=self.theme['button_fg'])

                elif widget_type in ['Entry', 'Text', 'Listbox']:
                    widget.config(bg=self.theme['entry_bg'],
                                  fg=self.theme['entry_fg'],
                                  insertbackground=self.theme['accent'],
                                  selectbackground=self.theme['accent'])
                    if 'highlightbackground' in widget.keys():
                        widget.config(highlightbackground=self.theme['border'],
                                      highlightcolor=self.theme['accent'])

                elif widget_type == 'Canvas':
                    if hasattr(widget, 'command'):  # ModernButton
                        widget.update_theme(self.theme)
                    else:
                        widget.config(bg=self.theme['bg'])

                # Recursively update children
                for child in widget.winfo_children():
                    update_widget(child)

            except Exception as e:
                pass

        update_widget(self.scrollable_frame)

        # Update radio buttons and checkboxes
        self.update_all_radios()

        # Update progress bar
        self.progress_fill.config(bg=self.theme['accent'])
        self.progress_text.config(bg=self.theme['accent'],
                                  fg=self.theme['button_fg'])

    def update_progress(self, value):
        """Update progress bar"""
        self.progress_var.set(value)
        self.progress_fill.place(relwidth=value / 100)
        self.progress_text.config(text=f"{int(value)}%")
        self.root.update_idletasks()

    def update_status(self, message):
        """Update status label"""
        self.status_label.config(text=message)

        # Color code based on message content
        if any(word in message.lower() for word in ['error', 'failed']):
            self.status_label.config(fg=self.theme['error'])
        elif any(word in message.lower() for word in ['complete', 'success']):
            self.status_label.config(fg=self.theme['success'])
        else:
            self.status_label.config(fg=self.theme['label_fg'])

        self.root.update_idletasks()

    def update_debug(self, message):
        """Update debug information"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.results_text.insert(tk.END, f"[{timestamp}] {message}\n")
        self.results_text.see(tk.END)
        self.root.update_idletasks()

    def toggle_password_visibility(self, entry_widget, button_widget):
        """Toggles the visibility of text in an entry widget."""
        if entry_widget.cget('show') == '*':
            entry_widget.config(show='')
            button_widget.text = "Hide"
            button_widget.draw_button()
        else:
            entry_widget.config(show='*')
            button_widget.text = "Show"
            button_widget.draw_button()

    def save_gui_config(self):
        """Saves the configuration from the GUI to the config file."""
        client_id = self.client_id_var.get()
        tenant_id = self.tenant_id_var.get()

        if not client_id or not tenant_id:
            messagebox.showwarning("Incomplete Configuration", "Both Client ID and Tenant ID must be provided.")
            return

        save_config(client_id, tenant_id, self.current_theme_name)
        self.load_gui_config()  # Reload to update global vars
        self.check_configuration()  # Update status
        messagebox.showinfo("Success", "Configuration saved successfully!")

    def set_quick_range(self, days):
        """Set a quick date range based on the number of days"""
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)

        self.start_date_var.set(start_date.strftime("%Y-%m-%d %H:%M"))
        self.end_date_var.set(end_date.strftime("%Y-%m-%d %H:%M"))

    def switch_mode(self):
        """Switch between online and local modes"""
        self.mode = self.mode_var.get()

        if self.mode == "online":
            # Hide local, show online
            self.local_config_frame.pack_forget()
            self.online_config_frame.pack(fill=tk.X)
            self.auth_container.pack(fill=tk.X, pady=(0, 15), padx=20)
            self.auth_button.pack(side=tk.LEFT, padx=(0, 10))
            self.clear_cache_button.pack(side=tk.LEFT, padx=(0, 10))
            self.clear_config_button.pack(side=tk.LEFT, padx=(0, 10))

            # Check configuration
            self.check_configuration()
        else:
            # Hide online, show local
            self.online_config_frame.pack_forget()
            self.auth_container.pack_forget()
            self.local_config_frame.pack(fill=tk.X)

            # Update status
            self.auth_status_label.config(text="Local Mode: No authentication required")

    def add_file(self):
        """Add a PST/OST file to the list"""
        file_path = filedialog.askopenfilename(
            title="Select PST/OST File",
            filetypes=[("PST/OST Files", "*.pst;*.ost"), ("PST Files", "*.pst"), ("OST Files", "*.ost"),
                       ("All Files", "*.*")]
        )

        if file_path:
            # Check if file is already in the list
            for i in range(self.file_listbox.size()):
                if self.file_listbox.get(i) == file_path:
                    messagebox.showwarning("Duplicate File", "This file is already in the list.")
                    return

            # Add to list
            self.file_listbox.insert(tk.END, file_path)

    def remove_file(self):
        """Remove the selected PST/OST file from the list"""
        selection = self.file_listbox.curselection()
        if selection:
            self.file_listbox.delete(selection[0])

    def add_mailbox(self):
        """Add a shared mailbox to the list"""
        mailbox = simpledialog.askstring("Add Shared Mailbox", "Enter the email address of the shared mailbox:")

        if mailbox:
            # Basic email validation
            if '@' not in mailbox or '.' not in mailbox.split('@')[1]:
                messagebox.showerror("Invalid Email", "Please enter a valid email address.")
                return

            # Check if mailbox is already in the list
            for i in range(self.mailboxes_listbox.size()):
                if self.mailboxes_listbox.get(i).lower() == mailbox.lower():
                    messagebox.showwarning("Duplicate Mailbox", "This mailbox is already in the list.")
                    return

            # Add to list
            self.mailboxes_listbox.insert(tk.END, mailbox)

    def remove_mailbox(self):
        """Remove the selected shared mailbox from the list"""
        selection = self.mailboxes_listbox.curselection()
        if selection:
            self.mailboxes_listbox.delete(selection[0])

    def update_mailbox_selection(self):
        """Update the UI based on mailbox selection"""
        if self.mailbox_option_var.get() == "shared":
            self.shared_mailboxes_frame.pack(fill=tk.X, pady=(10, 0))
        else:
            self.shared_mailboxes_frame.pack_forget()

    def check_configuration(self):
        """Check if CLIENT_ID and TENANT_ID are configured"""
        if not CLIENT_ID or not TENANT_ID:
            self.auth_status_label.config(text="Authentication Status: Not configured - See Configuration Help")
            return False
        else:
            self.auth_status_label.config(text="Authentication Status: Not authenticated")
            # Check for existing token
            self.check_existing_token()
            return True

    def check_existing_token(self):
        """Check for existing token in cache"""
        try:
            # Try to load token from cache file if it exists
            cache_file = "token_cache.bin"
            if os.path.exists(cache_file):
                with open(cache_file, "r") as f:
                    self.token_cache.deserialize(f.read())

            # Create MSAL app
            app = msal.PublicClientApplication(
                CLIENT_ID,
                authority=AUTHORITY,
                token_cache=self.token_cache
            )

            # Try to get token from cache
            accounts = app.get_accounts(username=None)
            if accounts:
                result = app.acquire_token_silent(SCOPES, account=accounts[0])
                if "access_token" in result:
                    self.access_token = result["access_token"]
                    self.auth_status_label.config(text="Authentication Status: Authenticated (cached)")
                    return

            self.auth_status_label.config(text="Authentication Status: Not authenticated")

        except Exception as e:
            self.auth_status_label.config(text=f"Authentication Status: Error - {str(e)}")

    def clear_cache(self):
        """Clear the authentication token cache and force reauthentication"""
        try:
            # Clear in-memory cache
            self.token_cache = msal.SerializableTokenCache()

            # Delete cache file if it exists
            cache_file = "token_cache.bin"
            if os.path.exists(cache_file):
                os.remove(cache_file)

            # Reset access token
            self.access_token = None

            # Update status
            self.auth_status_label.config(text="Authentication Status: Cache cleared - Please authenticate")

            # Show confirmation
            messagebox.showinfo("Cache Cleared",
                                "Authentication cache has been cleared successfully.\n\n"
                                "Please click 'Authenticate' to sign in again.")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to clear cache: {str(e)}")

    def clear_config(self):
        """Clear the saved Client ID and Tenant ID from the configuration file"""
        try:
            # Confirm with user
            if not messagebox.askyesno("Clear Configuration",
                                       "This will completely clear your saved Client ID and Tenant ID.\n\n"
                                       "You will need to reconfigure these values before using Online Mode.\n\n"
                                       "Do you want to continue?"):
                return

            # Clear the configuration file
            save_config("", "", self.current_theme_name)

            # Update global variables
            global CLIENT_ID, TENANT_ID, AUTHORITY
            CLIENT_ID = ""
            TENANT_ID = ""
            AUTHORITY = f"https://login.microsoftonline.com/{TENANT_ID}"

            # Update GUI variables
            self.client_id_var.set("")
            self.tenant_id_var.set("")

            # Clear authentication token
            self.access_token = None

            # Clear token cache
            self.token_cache = msal.SerializableTokenCache()
            cache_file = "token_cache.bin"
            if os.path.exists(cache_file):
                os.remove(cache_file)

            # Update status
            self.auth_status_label.config(text="Authentication Status: Configuration cleared - Not configured")

            # Show confirmation
            messagebox.showinfo("Configuration Cleared",
                                "Your Client ID and Tenant ID have been cleared successfully.\n\n"
                                "Please enter new values and click 'Save Configuration' before using Online Mode.")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to clear configuration: {str(e)}")

    def authenticate(self):
        """Authenticate with Microsoft Graph API"""
        if not self.check_configuration():
            return

        try:
            # Create MSAL app
            app = msal.PublicClientApplication(
                CLIENT_ID,
                authority=AUTHORITY,
                token_cache=self.token_cache
            )

            # Try to get token from cache
            accounts = app.get_accounts(username=None)
            if accounts:
                result = app.acquire_token_silent(SCOPES, account=accounts[0])
                if "access_token" in result:
                    self.access_token = result["access_token"]
                    self.auth_status_label.config(text="Authentication Status: Authenticated (cached)")
                    self.save_token_cache()
                    return

            # Try interactive browser authentication first
            self.auth_status_label.config(text="Authentication Status: Initiating browser login...")
            self.root.update()

            result = app.acquire_token_interactive(scopes=SCOPES)

            if "access_token" in result:
                self.access_token = result["access_token"]
                self.auth_status_label.config(text="Authentication Status: Authenticated")
                self.save_token_cache()
                messagebox.showinfo("Authentication Successful", "You have been successfully authenticated!")
            else:
                # If interactive fails, try device flow
                self.auth_status_label.config(text="Authentication Status: Trying device flow...")
                self.root.update()

                flow = app.initiate_device_flow(scopes=SCOPES)
                if "user_code" not in flow:
                    raise ValueError(
                        "Fail to create device flow. Err: %s" % json.dumps(flow, indent=4))

                # Display instructions
                message = ("To sign in, use a web browser to open the page "
                           f"{flow['verification_uri']} and enter the code "
                           f"{flow['user_code']} to authenticate.")

                # Show message box with instructions
                messagebox.showinfo("Authentication Required", message)

                # Open browser automatically
                webbrowser.open(flow['verification_uri'])

                # Wait for authentication
                result = app.acquire_token_by_device_flow(flow)

                if "access_token" in result:
                    self.access_token = result["access_token"]
                    self.auth_status_label.config(text="Authentication Status: Authenticated")
                    self.save_token_cache()
                    messagebox.showinfo("Authentication Successful", "You have been successfully authenticated!")
                else:
                    error_msg = result.get("error_description", "Unknown error")
                    self.auth_status_label.config(text=f"Authentication Status: Failed - {error_msg}")
                    messagebox.showerror("Authentication Failed", f"Error: {error_msg}")

        except Exception as e:
            error_msg = str(e)
            self.auth_status_label.config(text=f"Authentication Status: Error - {error_msg}")
            messagebox.showerror("Authentication Error", f"Error: {error_msg}")

    def save_token_cache(self):
        """Save token cache to file"""
        try:
            cache_file = "token_cache.bin"
            with open(cache_file, "w") as f:
                f.write(self.token_cache.serialize())
        except Exception as e:
            print(f"Error saving token cache: {str(e)}")

    def show_debug_info(self):
        """Show debug information for troubleshooting"""
        cache_file = "token_cache.bin"
        cache_exists = os.path.exists(cache_file)

        debug_info = f"""
        Debug Information:

        Current Mode: {self.mode}

        CLIENT_ID: {CLIENT_ID}
        TENANT_ID: {TENANT_ID}
        AUTHORITY: {AUTHORITY}
        SCOPES: {SCOPES}

        Token Cache Status: {'Has tokens' if self.token_cache.has_state_changed else 'No tokens'}
        Cache File Exists: {'Yes' if cache_exists else 'No'}
        Current Authentication Status: {'Authenticated' if self.access_token else 'Not authenticated'}

        PST/OST Support: {'Available' if PST_SUPPORT else 'Not available - Install libpff-win32 (Windows) or libpff (Linux/Mac)'}
        COM Support: {'Available' if COM_SUPPORT else 'Not available - Install pypiwin32'}

        Common Issues and Solutions:

        1. No contact data found:
           - Check if you have emails, contacts, or calendar events in the specified date range
           - For Online Mode: Verify that API permissions are granted
           - For Local Mode: Ensure PST/OST files contain data and are accessible
           - Try adjusting the date range for Online Mode
           - For shared mailboxes, ensure you have the necessary permissions

        2. Error "Application with identifier was not found in the directory":
           - Make sure you've entered the correct Client ID and Tenant ID in the Configuration section
           - Verify that your app is registered in the correct tenant
           - Check that you're using the correct tenant ID

        3. Error "No reply address is registered for the application":
           - Go to your app registration > "Authentication"
           - Under "Redirect URIs", make sure "http://localhost" is listed
           - Click "Add platform" and select "Mobile and desktop applications"
           - Enter "http://localhost" as the redirect URI
           - Click "Configure" and then "Save"

        4. Error "fail to create device flow. invalid_request and error code 55059":
           - Ensure your Azure AD app has "Allow public client flows" set to "Yes"
           - Check that your redirect URI is configured as "http://localhost"
           - Verify that your app is set as a "Public client/native" application

        5. Authentication permissions error:
           - Make sure an admin has granted consent for the API permissions
           - Check that all required permissions are added to your app registration
           - For shared mailboxes, ensure Mail.Read.Shared permission is granted

        6. Local mode issues:
           - Make sure you've installed the required libraries for PST/OST support
           - Ensure Outlook is installed if you want to scan the Outlook profile
           - Check that the PST/OST files are accessible and not corrupted

        7. Token cache issues:
           - Click "Clear Cache" to remove stored authentication tokens
           - This will force you to authenticate again with a fresh session
           - Useful when switching between different accounts or troubleshooting

        8. Configuration issues:
           - Click "Clear IDs" to remove saved Client ID and Tenant ID
           - This will completely reset your Azure AD configuration
           - Useful when switching to a different Azure AD tenant

        9. Shared mailbox issues:
           - Ensure you have the necessary permissions to access the shared mailbox
           - Check that the shared mailbox email address is correct
           - Verify that Mail.Read.Shared permission is granted in your app registration

        10. Teams chat issues:
            - Ensure Chat.Read permission is granted in your app registration
            - Some chats might not be accessible due to privacy settings
            - 1:1 chats require additional permissions compared to channel messages

        11. All mailboxes scanning issues:
            - Ensure you have the necessary permissions to access all mailboxes
            - Verify that User.Read.All permission is granted in your app registration
            - This feature may require administrator privileges

        12. Authentication scope error:
            - Fixed in this version by using only the .default scope
            - Make sure all required permissions are granted in your app registration
            - The .default scope will automatically include all permissions granted to the app

        13. Duplicate data issues:
            - Fixed in this version by improving deduplication logic
            - Phone numbers are now properly combined instead of overwritten
            - Company names are extracted from email domains when not found in signatures
            - Contacts with the same email are properly merged with the most complete information
        """

        messagebox.showinfo("Debug Information", debug_info)

    def show_config_help(self):
        """Show configuration help"""
        if self.mode == "online":
            config_help = """
            Online Mode Configuration Help:

            To use Online Mode, you must configure it with your Azure AD app details:

            1. Register an application in Azure AD:
               - Go to portal.azure.com
               - Navigate to "Azure Active Directory" > "App registrations"
               - Click "New registration"
               - Name: "Contact Extractor"
               - Supported account types: "Accounts in any organizational directory"
               - Redirect URI: Select "Public client/native (mobile & desktop)" and enter "http://localhost"
               - Click "Register"

            2. Configure API permissions:
               - Go to your app registration > "API permissions"
               - Click "Add a permission" > "Microsoft Graph"
               - Select "Delegated permissions" and add:
                 * Mail.Read
                 * Contacts.Read
                 * Calendars.Read
                 * Team.ReadBasic.All
                 * Chat.Read
                 * User.Read.All (required for scanning all mailboxes)
                 * Mail.Read.Shared (for shared mailboxes)
               - Click "Add permissions"
               - Click "Grant admin consent for [Your Organization]"

            3. Configure authentication:
               - Go to your app registration > "Authentication"
               - Under "Default client type", select "Yes" for "Treat application as a public client"
               - Under "Advanced settings", set "Allow public client flows" to "Yes"
               - Under "Redirect URIs", make sure "http://localhost" is listed
               - If not, click "Add platform" and select "Mobile and desktop applications"
               - Enter "http://localhost" as the redirect URI
               - Click "Configure" and then "Save"

            4. Get your Application (client) ID and Tenant ID:
               - From your app registration overview page, copy:
                 * Application (client) ID
                 * Directory (tenant) ID

            5. Update the application:
               - Enter the copied IDs into the "Azure AD Credentials" section in the app's GUI.
               - Click "Save Configuration".

            6. Token Management:
               - Use "Clear Cache" to remove stored authentication tokens
               - This forces reauthentication with a fresh session
               - Useful when switching between different accounts or troubleshooting

            7. Configuration Management:
               - Use "Clear IDs" to completely remove saved Client ID and Tenant ID
               - This is useful when switching to a different Azure AD tenant
               - After clearing, you'll need to reconfigure the app with new IDs

            8. Date and Time Range:
               - Use the date and time fields to specify the exact range to scan
               - Format: YYYY-MM-DD HH:MM (24-hour format)
               - Use the quick range buttons for common time periods
               - Larger date ranges may take longer to scan

            9. Mailbox Selection:
               - Choose "My mailbox only" to scan only your personal mailbox
               - Choose "All mailboxes in the organization" to scan every mailbox in your company
               - Choose "Specific shared mailboxes" to scan selected shared mailboxes
               - Note: Scanning all mailboxes requires administrator privileges

            10. Authentication Scopes:
                - The application now uses only the .default scope for authentication
                - This scope automatically includes all permissions granted to the app
                - Make sure all required permissions are granted in your app registration
                - This approach avoids the authentication error you were experiencing

            11. Troubleshooting:
                - If no data is found, try adjusting the date range
                - Check that you have emails, contacts, or calendar events in the specified range
                - Verify that API permissions are granted and not expired
                - For shared mailboxes, ensure you have the necessary permissions
                - For scanning all mailboxes, ensure you have administrator privileges

            12. Data Deduplication:
                - The application now properly deduplicates contacts based on email addresses
                - Phone numbers are combined instead of overwritten when multiple are found
                - Company names are extracted from email domains when not found in signatures
                - The most complete information is kept for each contact
            """
        else:
            config_help = """
            Local Mode Configuration Help:

            Local Mode scans PST/OST files and other local data sources for contact information.
            No authentication is required.

            1. Install required libraries:
               - Windows: pip install libpff-win32 pypiwin32 pandas openpyxl
               - Linux/Mac: pip install libpff pandas openpyxl

            2. Add PST/OST files:
               - Click "Add File" to select PST/OST files to scan
               - You can add multiple PST/OST files
               - Use "Remove" to remove selected files

            3. Configure scan options:
               - Check "Scan attachments" to include email attachments in the scan
               - Check "Scan subfolders" to include subfolders in PST/OST files

            4. Click "Start Scan" to begin scanning

            5. Export Options:
               - After scanning, you can export results to Excel, CSV, or HTML
               - All export formats are available for both Online and Local modes
               - Choose the format that best fits your needs

            6. Troubleshooting:
               - If no data is found, ensure PST/OST files contain emails with contacts
               - Check that the PST/OST files are accessible and not corrupted
               - Make sure Outlook is installed if you want to scan the Outlook profile
               - Try adding more PST/OST files if available

            7. Data Deduplication:
                - The application now properly deduplicates contacts based on email addresses
                - Phone numbers are combined instead of overwritten when multiple are found
                - Company names are extracted from email domains when not found in signatures
                - The most complete information is kept for each contact

            Note: For best results, make sure Outlook is installed if you want to scan the Outlook profile.
            """

        messagebox.showinfo("Configuration Help", config_help)

    def start_scan(self):
        """Start the data extraction process"""
        if self.mode == "online" and not self.access_token:
            messagebox.showwarning("Authentication Required",
                                   "Please authenticate first by clicking the 'Authenticate' button.")
            return

        if self.mode == "local" and self.file_listbox.size() == 0:
            response = messagebox.askyesno("No Files",
                                           "You haven't added any PST/OST files. Do you want to continue with scanning local files only?")
            if not response:
                return

        # Validate date range for online mode
        if self.mode == "online":
            try:
                start_date = datetime.strptime(self.start_date_var.get(), "%Y-%m-%d %H:%M")
                end_date = datetime.strptime(self.end_date_var.get(), "%Y-%m-%d %H:%M")

                if start_date >= end_date:
                    messagebox.showerror("Invalid Date Range", "Start date must be before end date.")
                    return

                if end_date > datetime.now():
                    messagebox.showwarning("Future Date",
                                           "End date is in the future. This may not return expected results.")
            except ValueError:
                messagebox.showerror("Invalid Date Format", "Please use the format: YYYY-MM-DD HH:MM")
                return

            # Check if scanning all mailboxes and warn about time
            if self.mailbox_option_var.get() == "all":
                response = messagebox.askyesno("Scan All Mailboxes",
                                               "Scanning all mailboxes in the organization can take a very long time.\n\n"
                                               "This feature requires administrator privileges.\n\n"
                                               "Do you want to continue?")
                if not response:
                    return

        # Disable buttons during scan
        self.start_button.config(state='disabled')
        if self.mode == "online":
            self.auth_button.config(state='disabled')
            self.clear_cache_button.config(state='disabled')
            self.clear_config_button.config(state='disabled')

        # Reset progress and status
        self.progress_var.set(0)
        self.status_label.config(text="Status: Starting scan...")
        self.results_text.delete(1.0, tk.END)
        self.results_text.insert(tk.END, "Scanning in progress...\n")
        self.results_text.insert(tk.END, "Debug Information:\n")
        self.results_text.insert(tk.END, "-" * 80 + "\n")

        # Start extraction in a separate thread
        self.extraction_thread = threading.Thread(target=self.run_extraction)
        self.extraction_thread.daemon = True
        self.extraction_thread.start()

    def run_extraction(self):
        """Run the data extraction in a separate thread"""
        try:
            if self.mode == "online":
                # Create online extractor instance
                extractor = OnlineDataExtractor(self.access_token)
                extractor.set_callbacks(self.update_progress, self.update_status, self.update_debug)

                # Set date range
                start_date = datetime.strptime(self.start_date_var.get(), "%Y-%m-%d %H:%M")
                end_date = datetime.strptime(self.end_date_var.get(), "%Y-%m-%d %H:%M")
                extractor.set_date_range(start_date, end_date)

                # Set the outbound-only flag
                extractor.set_outbound_only(self.outbound_only_var.get())

                # Determine mailbox selection
                shared_mailboxes = []
                scan_all_mailboxes = False

                if self.mailbox_option_var.get() == "all":
                    scan_all_mailboxes = True
                elif self.mailbox_option_var.get() == "shared":
                    for i in range(self.mailboxes_listbox.size()):
                        shared_mailboxes.append(self.mailboxes_listbox.get(i))

                # Extract data
                self.data = extractor.extract_all_data(shared_mailboxes, scan_all_mailboxes)
            else:
                # Create local extractor instance
                extractor = LocalDataExtractor()
                extractor.set_callbacks(self.update_progress, self.update_status, self.update_debug)

                # Add PST/OST files
                for i in range(self.file_listbox.size()):
                    file_path = self.file_listbox.get(i)
                    extractor.add_file_path(file_path)

                # Set scan options
                extractor.set_scan_options(
                    scan_attachments=self.scan_attachments_var.get(),
                    scan_subfolders=self.scan_subfolders_var.get()
                )

                # Extract data
                self.data = extractor.extract_all_data()

            # Update UI with results
            self.root.after(0, self.display_results)

        except Exception as e:
            error_msg = f"Error during extraction: {str(e)}"
            self.root.after(0, lambda: self.update_status(error_msg))
            self.root.after(0, lambda: self.results_text.insert(tk.END, f"\n{error_msg}"))
        finally:
            # Re-enable buttons
            self.root.after(0, self.enable_buttons)

    def display_results(self):
        """Display extraction results"""
        # Add separator for results
        self.results_text.insert(tk.END, "\n" + "-" * 80 + "\n")
        self.results_text.insert(tk.END, "Extraction Results:\n")
        self.results_text.insert(tk.END, "-" * 80 + "\n")

        if not self.data:
            self.results_text.insert(tk.END, "No contact data found.\n")
            self.results_text.insert(tk.END, "\nPossible reasons:\n")
            self.results_text.insert(tk.END, "- No emails, contacts, or calendar events in the specified date range\n")
            self.results_text.insert(tk.END, "- API permissions not properly configured\n")
            self.results_text.insert(tk.END, "- PST/OST files don't contain contact information\n")
            self.results_text.insert(tk.END, "- No access to shared mailboxes or Teams chats\n")
            self.results_text.insert(tk.END, "- Insufficient permissions to access all mailboxes\n")
            return

        # Display summary
        self.results_text.insert(tk.END, f"Found {len(self.data)} unique contacts.\n\n")

        # Display sample of results
        self.results_text.insert(tk.END, "Sample Results:\n")
        self.results_text.insert(tk.END, "-" * 80 + "\n")

        for i, contact in enumerate(self.data[:20]):  # Show first 20 contacts
            phone = contact.get('Phone Number', '')
            company = contact.get('Company Name', '')
            phone_text = f" - Phone: {phone}" if phone else ""
            company_text = f" - Company: {company}" if company else ""
            self.results_text.insert(tk.END,
                                     f"{i + 1}. {contact['First Name']} {contact['Last Name']} - {contact['Email']}{phone_text}{company_text} (Source: {contact['Source']})\n")

        if len(self.data) > 20:
            self.results_text.insert(tk.END, f"... and {len(self.data) - 20} more contacts.\n")

        # Enable export buttons for both modes
        self.export_excel_button.config(state='normal')
        self.export_csv_button.config(state='normal')
        self.export_html_button.config(state='normal')

    def enable_buttons(self):
        """Re-enable buttons after extraction"""
        self.start_button.config(state='normal')
        if self.mode == "online":
            self.auth_button.config(state='normal')
            self.clear_cache_button.config(state='normal')
            self.clear_config_button.config(state='normal')

    def export_data(self, format_type):
        """Export data to the specified format"""
        if not self.data:
            messagebox.showwarning("No Data", "No data to export.")
            return

        try:
            # Create DataFrame
            df = pd.DataFrame(self.data)

            # Get filename based on format
            if format_type == "excel":
                filename = filedialog.asksaveasfilename(
                    defaultextension=".xlsx",
                    filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")]
                )
                if filename:
                    df.to_excel(filename, index=False)
                    messagebox.showinfo("Export Successful", f"Data exported to {filename}")

            elif format_type == "csv":
                filename = filedialog.asksaveasfilename(
                    defaultextension=".csv",
                    filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
                )
                if filename:
                    df.to_csv(filename, index=False)
                    messagebox.showinfo("Export Successful", f"Data exported to {filename}")

            elif format_type == "html":
                filename = filedialog.asksaveasfilename(
                    defaultextension=".html",
                    filetypes=[("HTML files", "*.html"), ("All files", "*.*")]
                )
                if filename:
                    html = df.to_html(index=False)
                    with open(filename, "w") as f:
                        f.write(html)
                    messagebox.showinfo("Export Successful", f"Data exported to {filename}")

        except Exception as e:
            messagebox.showerror("Export Error", f"Error exporting data: {str(e)}")


def main():
    """Main function to run the application"""
    root = tk.Tk()
    app = ContactExtractorApp(root)
    root.mainloop()


if __name__ == "__main__":
    main()
